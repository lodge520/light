<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <title>æ™ºèƒ½ç¯æ§</title>
  <script src="tf.min.js"></script>
  <script src="body-pix.min.js"></script>
  <script src="chart.js"></script>
  <script src="interact.js"></script>
  <script src="countup.js"></script>
  <style>
     :root {
      --primary: #409EFF;
      --primary-hover: #66B1FF;
        --bg: 
    linear-gradient(rgba(240,242,245,0.7), rgba(240,242,245,0.5)),
      url("./images/store-bg-blur.png")
       no-repeat center center fixed;
      --card-bg: #FFFFFF;
      --text-color: #303133;
      --sub-text: #606266;
      --border-radius: 12px;
      --transition: 0.3s ease;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Helvetica Neue", sans-serif;
        background: var(--bg);
       background-size: cover;
      color: var(--text-color);
      padding: 20px;
      background-color: rgba(240,242,245,0.8);
    }
    
    /* æ§åˆ¶åŒº */
    #controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      background: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      margin-bottom: 20px;
    }
    #controls button {
      background: var(--primary);
      color: #fff;
      border: none;
      padding: 8px 14px;
      border-radius: 999px;
      cursor: pointer;
      transition: background var(--transition), transform 0.2s;
    }
    #controls button:hover {
      background: var(--primary-hover);
      transform: translateY(-1px);
    }
    #controls label {
      font-size: 14px;
      color: var(--sub-text);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #controls input[type="text"] {
      width: 140px;
      padding: 6px 10px;
      font-size: 14px;
      border: 1px solid #dcdfe6;
      border-radius: 4px;
      transition: border-color 0.3s;
    }
    #controls input[type="text"]:focus {
      border-color: var(--primary);
      outline: none;
    }
    #scanStatus {
      margin-left: auto;
      font-size: 13px;
      color: var(--sub-text);
    }

    /* è®¾å¤‡å¡ç‰‡ç½‘æ ¼ */
    #deviceContainer {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
    }
    .lamp-card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .lamp-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    }
    .lamp-card h3 {
      font-size: 18px;
      margin-bottom: 8px;
    }
    .lamp-card label {
      font-size: 14px;
      color: var(--sub-text);
      margin-top: 12px;
      display: block;
    }
    .lamp-card input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      margin-top: 6px;
    }
    .lamp-card input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      transition: background var(--transition), transform 0.2s;
    }
    .lamp-card input[type="range"]::-webkit-slider-thumb:hover {
      background: var(--primary-hover);
      transform: scale(1.2);
    }
    .color-box {
      display: inline-block;
      margin-top: 10px;
      width: 180px; height: 40px;
      line-height: 40px;
      text-align: center;
      border-radius: var(--border-radius);
      border: 1px solid #ccc;
      box-shadow: inset 0 0 4px rgba(0,0,0,0.08);
      background: #888; color: #fff;
      margin-left: 10px;
    }
    .upload-btn-wrapper {
      display: inline-block;
      padding: 8px 12px;
      background: var(--primary);
      color: #fff;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 13px;
      margin-top: 6px;
      transition: background var(--transition);
      width: auto;      
      max-width: 80px; 
    }
    .upload-btn-wrapper:hover {
      background: var(--primary-hover);
    }
    .upload-btn-wrapper input {
      display: none;
    }
    .btn-delete {
      display: inline-block;
      margin-top: 10px;
      padding: 8px 12px;
      background: #F56C6C;
      color: #fff;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 13px;
      margin-top: 6px;
      transition: background var(--transition);
      width: auto;     
      max-width: 80px; 
    }
    .btn-delete:hover {
      background: #F78989;
    }
.flow-upload-btn {
  display: inline-block;
  padding: 8px 12px;
  background: #409EFF;       /* å¤©è“è‰²ï¼ŒåŒºåˆ«äºä¸»è‰² */
  color: #fff;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 13px;
  margin-top: 6px;
  transition: background var(--transition);
  width: auto;
  max-width: 80px;
  user-select: none;
  border: none;
  text-align: center;
}

.flow-upload-btn:hover {
  background: #66b1ff;       /* æµ…è“è‰²æ‚¬æµ® */
}

.flow-upload-btn.active {
  background: #2c82d8;       /* æ¿€æ´»æ—¶æ›´æ·±è“ */
  box-shadow: 0 0 6px rgba(44,130,216,0.8);
}

.detect-upload-btn {
  display: inline-block;
  padding: 8px 12px;
  background: #67C23A;       /* ç»¿è‰²ï¼Œå’Œæµé‡æŒ‰é’®åŒºåˆ« */
  color: #fff;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 13px;
  margin-top: 6px;
  transition: background var(--transition);
  width: auto;
  max-width: 80px;
  user-select: none;
  border: none;
  text-align: center;
}

.detect-upload-btn:hover {
  background: #85ce61;       /* æµ…ç»¿æ‚¬æµ® */
}

.detect-upload-btn.active {
  background: #4ea32f;       /* æ¿€æ´»æ—¶æ›´æ·±ç»¿ */
  box-shadow: 0 0 6px rgba(78,163,47,0.8);
}

       canvas#sceneCanvas {
  background: url('./images/store-bg.jpg');
  background-size: cover;
  width: 100%;
  height: auto;
  max-width: 900px;
  border: 1px solid #333;
  border-radius: 12px; 
  display: block;
   margin: 20px 0 20px auto;
  box-shadow: 0 12px 20px rgba(0,0,0,0.4);
}
    #panel {
  position: absolute;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(34, 34, 34, 0.85);  /* æ”¹ä¸ºåŠé€æ˜é»‘ç° */
  padding: 20px;
  border: 1px solid #888;              /* å˜æµ…è‰² */
  border-radius: 12px;                 /* åœ†è§’ä¼˜åŒ– */
  display: none;
  z-index: 10;
  color: #eee;                         /* å­—ä½“æ”¹æµ…è‰² */
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); /* æ·»åŠ æŸ”å’Œé˜´å½± */
}

#panel input[type="range"] {
  width: 200px;
}

#panel label {
  display: inline-block;
  width: 60px;
  text-align: right;
  margin-right: 10px;
  color: #ccc;                       
}

#panel button {
  margin-top: 10px;
  background-color: #409EFF;
  color: white;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
}
#panel button:hover {
  background-color: #66B1FF;
}
 
  .env-wrapper {
  display: flex;
  justify-content: space-between;
  gap: 24px;
  flex-wrap: wrap;
  margin-bottom: 20px;
}

.env-left,
.env-right {
  flex: 1 1 45%;
  min-width: 300px;
}

#selectorBox {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  justify-content: center;
  background-color: rgba(255, 255, 255, 0.85);
  padding: 16px 20px;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
  margin-bottom: 20px;
}

/* é€šç”¨æŒ‰é’®å’Œä¸‹æ‹‰æ¡†æ ·å¼ */
#selectorBox select,
#selectorBox button {
  width: auto;
  max-width: 160px;
  min-width: 100px;
  height: 38px;
  padding: 6px 14px 6px 14px;
  font-size: 14px;
  border-radius: 999px;
  border: 1px solid #ccc;
  white-space: nowrap;
  background-color: #f9f9f9;
  transition: all 0.2s ease;
  flex: none;
}

/* ä¸‹æ‹‰ç®­å¤´ç¾åŒ– */
#selectorBox select {
  background-image: url("data:image/svg+xml;utf8,<svg fill='gray' height='12' viewBox='0 0 24 24' width='12' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
  background-repeat: no-repeat;
  background-position: right 10px center;
  background-size: 12px 12px;
  padding-right: 30px;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  cursor: pointer;
}

/* é¼ æ ‡æ‚¬åœæ—¶æ ·å¼ */
#selectorBox select:hover,
#selectorBox button:hover {
  border-color: #aaa;
  background-color: #f1f1f1;
}

/* æŒ‰é’®æ ·å¼è¦†ç›– */
#selectorBox button {
  background-color: #409EFF;
  color: white;
  border: none;
  font-weight: 500;
}

#selectorBox button:hover {
  background-color: #66b1ff;
}

.env-layout {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 24px;
}
.env-card {
  flex: 1 1 48%;
  min-width: 300px;
  background: #fff;
  padding: 16px;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
 
 #metaInfo {
  display: grid;
  grid-template-columns: auto auto;
  column-gap: 30px;
  row-gap: 6px;
  margin-top: 12px;
  
}

#metaInfo > div {
  margin: 0;
}

/* å¤–å±‚å®¹å™¨ â€”â€” å·¦å³ä¸¤æ  */
.app-container {
  display: flex;
  height: 100vh;
}

/* ä»»åŠ¡æ  */
.sidebar {
  width: 200px;
  background: var(--card-bg);
  box-shadow: 2px 0 8px rgba(0,0,0,0.04);
  border-right: 1px solid #eee;
  padding: 30px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  border-radius: var(--border-radius);

}

.sidebar ul {
  width: 100%;
  list-style: none;
  padding: 0;
  margin: 0;
}

.sidebar li {
  position: relative;
  width: 90%;
  margin: 8px auto;
  padding: 10px 16px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  color: var(--text-color);
  transition: background 0.2s, color 0.2s;
}
/* å·¦ä¾§é«˜äº®æ¡ */
.sidebar li.active::before {
  content: "";
  position: absolute;
  left: -2px;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 60%;
  background: var(--primary);
  border-radius: 2px 0 0 2px;
}
/* é€‰ä¸­æ€å’Œæ‚¬åœæ€ */
.sidebar li.active,
.sidebar li:hover {
  background: rgba(64,158,255,0.1);
  color: var(--primary);
}

.sidebar li svg,
.sidebar li .icon {
  width: 20px;
  height: 20px;
  fill: currentColor;
}

/* ä¸»å†…å®¹åŒº */
.main-content {
  flex: 1;
   display: block;
  overflow: auto;
  padding: 20px;
  box-sizing: border-box;
}
/* é€šç”¨å¡ç‰‡é£æ ¼ */
.chart-card,
.info-card {
  background: var(--card-bg);
  border-radius: var(--border-radius);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  padding: 12px;
  margin-bottom: 16px;
}

/* å¡ç‰‡æ ‡é¢˜ */
.card-title {
  font-size: 1.125rem;
  margin-bottom: 12px;
  border-bottom: 1px solid #eee;
  padding-bottom: 4px;
}

/* çªå‡ºé«˜äº®æ–‡å­— */
.highlight span {
  color: var(--primary);
  font-weight: bold;
  font-size: 1.125rem;
}

/* ä¸¤åˆ—æ …æ ¼ï¼ˆå“åº”å¼ï¼‰ */
.chart-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
}
.chart-card,
.info-card {
  padding: 12px;        
  margin-bottom: 16px;  
}


.chart-card canvas,
.chart-grid canvas {
  width: 100% !important;
  height: 280px !important;  
}

/* æ …æ ¼åˆ—é—´è· */
.chart-grid {
  gap: 16px;  
}

.canvas-layout {
  display: flex;
  gap: 20px;
  height: 520px;
}

.canvas-side {
  display: grid;
  margin-top: 23px;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  width: 450px;
  height: 480px;
}
/*æ€»ä½“æ§åˆ¶æŒ‰é’®*/
.side-card {
  height: 220px;
  background: #fff;
  border-radius: 30px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 500;
  padding: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid transparent;
}

.side-card.active {
  background: #f0f8ff;
  border: 2px solid var(--primary, #409EFF);
  box-shadow: 0 4px 16px rgba(64, 158, 255, 0.2);
}

.side-card:hover {
  background: #f0f8ff;
  transform: translateY(-2px);
}

.gear-icon {
  display: inline-block;
  vertical-align: middle;
  margin-right: 6px;
  transform-origin: 50% 50%;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to   { transform: rotate(360deg); }
}

/* åªæœ‰ .active æ—¶ï¼Œé½¿è½®æ‰ä¸åœæ—‹è½¬ */
#autoModeCard.active .gear-icon {
  animation: spin 1s linear infinite;
}

/* è®©ç¦ç”¨çš„æ»‘å—åŠé€æ˜ã€é”æ‰‹å‹å…‰æ ‡ */
input[type="range"]:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.env-card.entime {
  position: relative;        /* ä½¿å†…éƒ¨ç»å¯¹å®šä½ç”Ÿæ•ˆ */
  padding: 30px;
  border-radius: 12px;
  background: #fff;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    width: 100%;
    height: 100%;
  box-sizing: border-box;
}
/* æ—¶é—´/æ—¥æœŸçš„å®¹å™¨ */
.time-container {
  position: absolute;
  top: 16px;
  right: 16px;
  text-align: right;
  margin-right: 30px;

}

.time-row {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}
/* å½“å‰æ—¶é—´ï¼šå¤§å·ç²—ä½“ */
.current-time {
  font-size: 2rem;       /* ä½ å¯ä»¥æ”¹æˆ 2rem æ›´å¤§ */
  font-weight: bold;
  line-height: 1;
}

/* å½“å‰æ—¥æœŸï¼šå°å·ç°è‰² */
.current-date ,.current-week{
  font-size: 0.9rem;     /* æ¯”æ—¶é—´å°ä¸€ç‚¹ */
  color: #666;
  margin-top: 4px;
}

/* æ‰‹æœºç«¯ï¼šå°äº 768px æ—¶ */
@media (max-width: 768px) {
  /* æ•´ä¸ªå¤–å±‚ä¸Šä¸‹æ’åˆ— */
  .app-container {
    flex-direction: column;
  }

  /* æŠŠä¾§è¾¹æ å˜æˆå›ºå®šåœ¨é¡¶éƒ¨çš„æ¨ªæ¡ */
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    padding: 0;
    margin: 0;
    border-right: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    background: var(--card-bg);
    z-index: 1000;
  }
  /* æ¨ªå‘åˆ—è¡¨ */
  .sidebar ul {
    display: flex;
    flex-direction: row;
    width: 100%;
    padding: 0;
    margin: 0;
  }
  .sidebar li {
    flex: 1;
    margin: 0;
    border-radius: 0;
    text-align: center;
    padding: 12px 0;
  }
  .sidebar li.active::before {
    /* æŠŠå·¦ä¾§é«˜äº®æ¡æ”¹æˆé¡¶éƒ¨é«˜äº®æ¡ */
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    border-radius: 0;
  }

  .main-content {
    margin-top: 48px; /* æ ¹æ®ä½  li çš„é«˜åº¦è°ƒæ•´ */
    padding: 12px;
  }

  .canvas-layout {
    display: flex;            /* ç¡®ä¿æ˜¯ flex å¸ƒå±€ */
    flex-direction: column;   /* ç«–ç€æ’ */
    gap: 8px;                 /* æŒ‰é’®åŒºå’Œç”»å¸ƒä¹‹é—´ç•™ç‚¹ç¼éš™ */
  }

  /* 2) æŒ‰é’®åŒºé“ºæ»¡æ•´è¡Œï¼Œå¹¶æ¨ªå‘æ»šåŠ¨ */
  .canvas-side {
    display: flex !important;    /* æ¨ªå‘æ»šåŠ¨çš„ flex */
    flex-wrap: nowrap;           /* ä¸æ¢è¡Œ */
    overflow-x: visible;         
    width: 100%;                 /* æ‹‰æ»¡å®½åº¦ */

  }

  /* 3) è¦†ç›–æ‰åŸæ¥çš„å›ºå®šé«˜åº¦ï¼ŒæŒ‰å®½åº¦è‡ªé€‚åº”æˆæ­£æ–¹å½¢ */
  .canvas-side .side-card {
    flex: 1 1 0;             
    max-width: none;              
    height: auto !important;     
    max-height: 130px;
    aspect-ratio: auto;          
    font-size: 14px;             
    padding: 0 12px;               
  }

  /* 4) ç”»å¸ƒä¸‹æŒªä¸”é“ºæ»¡ */
  #sceneCanvas {
    width: 100% !important;
    height: auto !important;
  }

}
 </style>
</head>
<body>
   <div class="app-container">
    <!-- å·¦ä¾§ä»»åŠ¡æ  -->
    <nav class="sidebar">
      <ul>
        <li class="active" data-tab="main">å®æ—¶ç¯æ§</li>
        <li data-tab="flow">äººæµæŠ˜çº¿å›¾</li>
        <li data-tab="settings">è®¾ç½®</li>
      </ul>
    </nav>
      <div class="main-content"> 
        <section id="mainSection">

  <div class="time-container">
    <div class="current-time"div id="curtime">01:39:21</div>
<div class="time-row">
   <p id="weatherDisplay" style="margin-top: -8px; font-size: 14px; color: #666;">
  å¤©æ°”ä¿¡æ¯åŠ è½½ä¸­â€¦
</p>
    <div class="current-week"  id="weekInfo">æ˜ŸæœŸï¼šäº”</div>
    <div class="current-date" id="dateInfo">2025/7/08</div>
</div>

    </div>
</br></br>

  <div class="env-layout card-section">
    <div class="env-card">
    <h4>å®æ—¶ç¯å¢ƒå‚æ•°</h4>
    <div id="inputs"></div>
</div>
          
          <div class="env-card"><div id="metaInfo">
<div id="holidayInfo">æ˜¯å¦èŠ‚å‡æ—¥: å¦</div>
<div id="workdayInfo">æ˜¯å¦å·¥ä½œæ—¥: æ˜¯</div>
</div>
<div id="luxDisplay" style="margin-top: 1em; padding: 10px; background: #f9f9f9; border-radius: 8px;">
  ğŸ’¡ å…‰ç…§å€¼ç­‰å¾…æ›´æ–°ä¸­...
</div>
</div>
</div>

  <h1>æ™ºèƒ½ç¯æ§</h1></br>
  <div id="controls">
    <button onclick="startDeviceScan()">æ‰«æè®¾å¤‡</button>
    <button onclick="showAddDeviceModal()">æ‰‹åŠ¨æ·»åŠ è®¾å¤‡</button>
    <label>
      WebSocket æœåŠ¡å™¨åœ°å€ï¼š
      <input type="text" id="wsServerInput" placeholder="110.41.81.4">
    </label>
    <div id="scanStatus"></div>
  </div>

<div id="addDeviceModal" style="
  display:none; position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.4); z-index:9999; justify-content:center; align-items:center;
  font-family:'Helvetica Neue', sans-serif;">
  <div style="
    background:#fff; padding:30px 25px; border-radius:18px; width:320px;
    box-shadow:0 8px 30px rgba(0,0,0,0.2); text-align:center; animation:fadeIn 0.3s ease;">
    <h3 style="margin-top:0; font-size:20px; color:#333;">æ‰‹åŠ¨æ·»åŠ è®¾å¤‡</h3>
    <label style="display:block; text-align:left; margin-bottom:4px;">è®¾å¤‡ IDï¼š</label>
    <input type="text" id="modalId" placeholder="å¦‚ lamp2" style="
      width:100%; padding:10px; border-radius:8px; border:1px solid #ccc; margin-bottom:15px;
      font-size:14px; box-sizing:border-box;">

    <label style="display:block; text-align:left; margin-bottom:4px;">è®¾å¤‡ IPï¼š</label>
    <input type="text" id="modalIp" placeholder="å¦‚ 192.168.1.105" style="
      width:100%; padding:10px; border-radius:8px; border:1px solid #ccc; margin-bottom:20px;
      font-size:14px; box-sizing:border-box;">

    <button onclick="confirmAddDevice()" style="
      background:#4CAF50; color:#fff; padding:10px 20px; border:none;
      border-radius:10px; cursor:pointer; font-size:14px; margin-right:10px;
      transition:background 0.3s;">ç¡®è®¤æ·»åŠ </button>

    <button onclick="hideAddDeviceModal()" style="
      background:#ccc; color:#333; padding:10px 20px; border:none;
      border-radius:10px; cursor:pointer; font-size:14px;
      transition:background 0.3s;">å–æ¶ˆ</button>
  </div>
</div>

<div class="canvas-layout">
  <div class="canvas-side">
<div class="side-card" onclick="selectSceneCard(this, 3000)">æš–å…‰</div>
<div class="side-card" onclick="selectSceneCard(this, 4500)">ä¸­æ€§ç™½</div>
<div class="side-card" onclick="toggleColorTempLoop(this)">å¾ªç¯</div>

<div class="side-card" id="autoModeCard" onclick="selectAutoMode(this)">
  <svg
    class="gear-icon"
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    width="32" height="32"      
    fill="#007bff"            
  >
    <path d="M19.14 12.94
             c.04-.3.06-.61.06-.94
             s-.02-.64-.06-.94
             l2.03-1.58
             c.18-.14.23-.41.12-.61
             l-1.92-3.32
             c-.12-.21-.37-.28-.58-.2
             l-2.39.96
             c-.5-.38-1.04-.7-1.64-.94
             L14.96 2.81
             c-.05-.22-.24-.38-.47-.38
             h-3.78
             c-.23 0-.42.16-.47.38
             l-.36 2.49
             c-.6.24-1.14.56-1.64.94
             l-2.39-.96
             c-.22-.09-.47-.01-.58.2
             l-1.92 3.32
             c-.12.21-.07.47.12.61
             l2.03 1.58
             c-.05.3-.06.61-.06.94
             s.02.64.06.94
             l-2.03 1.58
             c-.18.14-.23.41-.12.61
             l1.92 3.32
             c.12.21.37.28.58.2
             l2.39-.96
             c.5.38 1.04.7 1.64.94
             l.36 2.49
             c.05.22.24.38.47.38
             h3.78
             c.23 0 .42-.16 .47-.38
             l.36-2.49
             c.6-.24 1.14-.56 1.64-.94
             l2.39.96
             c.22.09 .47.01 .58-.2
             l1.92-3.32
             c.12-.21 .07-.47-.12-.61
             l-2.03-1.58z
           M12 15.5
             c-1.93 0-3.5-1.57-3.5-3.5
             s1.57-3.5 3.5-3.5
             3.5 1.57 3.5 3.5
             -1.57 3.5-3.5 3.5z"/>
  </svg>
  è‡ªåŠ¨æ¨¡å¼</div>

  </div>
  <canvas id="sceneCanvas" width="900" height="500"></canvas>
  <input type="file" id="uploader" accept="image/*" style="display:none;">
 </section> 

<section id="flowSection" style="display:none">
  <h2>äººæµæŠ˜çº¿å›¾</h2>
  <!-- ç­–ç•¥å¯¹æ¯”å¡ç‰‡ -->
  <div class="chart-grid">
    <!--å·¦ä¾§çƒ­åŠ›å›¾-->
<div class="chart-card">
  <canvas id="heatmapCanvas" width="500" height="260"></canvas>
</div>

    <!-- å³ä¾§ç­–ç•¥å›¾ -->
    <div class="chart-card">
      <div class="card-title">äº®åº¦ç­–ç•¥å®æ—¶å¯¹æ¯”å›¾</div>
      <canvas id="strategyChart"></canvas>
    </div>
  </div>

  <!-- ä¿¡æ¯å¡ç‰‡ï¼šèŠ‚èƒ½ç‡è®¡ç®— -->
  <div class="info-card">
    <div class="card-title">èŠ‚èƒ½ç‡è®¡ç®—</div>
    <p>
      å…¬å¼ï¼š<br>
      èŠ‚èƒ½ç‡ â‰ˆ (5 â€“ æ··åˆç­–ç•¥äº®åº¦ Ã· æ’å®šäº®åº¦) Ã— 100% Ã— èˆ’é€‚åº¦ç³»æ•°<br>
      å¯¹æ¯”æ¯”ä¾‹ 3:7
    </p>
    <p class="highlight">
      <span id="SavingResult">èŠ‚èƒ½ç‡: 7.8%</span>

    </p>
  </div>

  <!-- ä¸¤åˆ—æ …æ ¼ï¼šæ¸©åº¦&äººæµ + æ¯ç›ç¯äº®åº¦ -->
  <div class="chart-grid">
    <div class="chart-card">
      <div class="card-title">æ¸©åº¦ & äººæµ</div>
      <canvas id="tempChart" width="600" height="200"></canvas>
    </div>
    <div class="chart-card">
      <div class="card-title">æ¯ç›ç¯äº®åº¦ï¼ˆæµæ˜ï¼‰</div>
      <canvas id="distributionChart" width="600" height="200"></canvas>
    </div>
  </div>

  <!-- ä¿¡æ¯å¡ç‰‡ï¼šäº®åº¦è®¡ç®—ç»“æœ -->
  <div class="info-card">
    <div class="card-title">äº®åº¦è®¡ç®—ç»“æœ</div>
    <p>
      å½“å‰äº®åº¦ï¼š<span id="currentBriDisplay">661 æµæ˜/ç›</span>
    </p>
  </div>
</section>

<section id="settingsSection" style="display: none; padding: 10px; font-family: sans-serif; color: #333;">
<!-- é¡¶éƒ¨é€‰æ‹©å™¨åŒºåŸŸ -->
<div id="selectorContainer">
  <div id="selectorBox"> <h2>âš™ï¸ åº—é“ºè®¾ç½®ï¼š </h2>
    <select id="citySelect">
      <option value="28.1894,112.9861" selected>é•¿æ²™</option>
      <option value="31.2304,121.4737">ä¸Šæµ·</option>
      <option value="39.9042,116.4074">åŒ—äº¬</option>
      <option value="23.1291,113.2644">å¹¿å·</option>
    </select>

    <select id="storeTypeSelect">
      <option value="é«˜ç«¯,3500">é«˜ç«¯åº—ï¼ˆ3500Kï¼‰</option>
      <option value="ä¸­ç«¯,4000">å¤§ä¼—åº—ï¼ˆ4000Kï¼‰</option>
      <option value="å°å‹,5000">å¿«é”€åº—ï¼ˆ5000Kï¼‰</option>
    </select>

    <select id="storeSelect">
      <option value="å°å‹,40">40ã¡</option>
      <option value="ä¸­ç«¯,60">60ã¡</option>
      <option value="é«˜ç«¯,80" selected>80ã¡</option>
    </select>

    <button id="toggleMode">åˆ‡æ¢æ—¥å¤œæ¨¡å¼</button>
  </div>
</div>

  <div style="display: flex; gap: 40px; flex-wrap: wrap;">

    <!-- å·¦ä¾§ï¼šçƒ­åŒºæ—¶é•¿æŸ¥è¯¢ -->
    <div style="flex: 1 1 320px; background: #f9f9f9; padding: 20px; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1);">
      <h2 style="margin-top: 0; border-bottom: 2px solid #ff4d4f; padding-bottom: 6px;">ğŸ“… çƒ­åŒºæ—¶é•¿æŸ¥è¯¢</h2>
      <div style="margin-top: 10px; margin-bottom: 12px;">
        <label for="start-date" style="margin-right: 8px;">èµ·å§‹æ—¥æœŸï¼š</label>
        <input type="date" id="start-date" name="start-date" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc;" />
      </div>
      <div style="margin-bottom: 12px;">
        <label for="end-date" style="margin-right: 8px;">ç»“æŸæ—¥æœŸï¼š</label>
        <input type="date" id="end-date" name="end-date" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc;" />
      </div>
      <div style="margin-bottom: 20px;">
        <label for="recent-days" style="margin-right: 8px;">æœ€è¿‘å¤©æ•°ï¼š</label>
        <select id="recent-days" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc;">
          <option value="">ä¸ä½¿ç”¨</option>
          <option value="1" selected>1 å¤©å†…</option>
          <option value="3">3 å¤©å†…</option>
          <option value="7">7 å¤©å†…</option>
          <option value="14">14 å¤©å†…</option>
          <option value="30">30 å¤©å†…</option>
        </select>
      </div>
      <button onclick="queryDuration()" style="background-color: #ff4d4f; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">æŸ¥è¯¢</button>

      <table id="duration-result" border="1" style="margin-top: 1rem; display: none; width: 100%; max-width: 500px; border-collapse: collapse; font-size: 14px;">
        <thead style="background-color: #fff1f0; color: #a8071a;">
          <tr>
            <th style="padding: 8px; border: 1px solid #ffccc7;">è®¾å¤‡ID</th>
            <th style="padding: 8px; border: 1px solid #ffccc7;">åœç•™æ—¶é•¿ï¼ˆç§’ï¼‰</th>
          </tr>
        </thead>
        <tbody id="duration-body"></tbody>
      </table>
    </div>

<!-- å³ä¾§ï¼šæœºæ¢°è‡‚æ§åˆ¶ -->
<div style="flex: 1 1 250px; background: #e6f7ff; padding: 20px; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1); position: relative;">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <h2 style="margin: 0; border-bottom: 2px solid #1890ff; padding-bottom: 6px; flex: 1;">ğŸ¤– æœºæ¢°è‡‚æ§åˆ¶</h2>
    <!-- è®¾å¤‡é€‰æ‹©ä¸‹æ‹‰ -->
    <select id="deviceSelect" style="margin-left: 10px; padding: 4px 6px; border-radius: 4px; border: 1px solid #ccc;">
      <option value="">é€‰æ‹©è®¾å¤‡</option>
      <option value="camlamp1">camlamp1</option>
      <option value="camlamp2">camlamp2</option>
    </select>
  </div>

  <!-- æ§åˆ¶æŒ‰é’® -->
  <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 16px;">
    <button onclick="sendArmCommand('up')" style="flex: 1 1 45%; padding: 12px 0; font-size: 18px; border: none; background-color: #1890ff; color: white; border-radius: 6px; cursor: pointer;">â¬† ä¸Š</button>
    <button onclick="sendArmCommand('down')" style="flex: 1 1 45%; padding: 12px 0; font-size: 18px; border: none; background-color: #1890ff; color: white; border-radius: 6px; cursor: pointer;">â¬‡ ä¸‹</button>
    <button onclick="sendArmCommand('left')" style="flex: 1 1 45%; padding: 12px 0; font-size: 18px; border: none; background-color: #13c2c2; color: white; border-radius: 6px; cursor: pointer;">âŸ² äººæµ</button>
    <button onclick="sendArmCommand('right')" style="flex: 1 1 45%; padding: 12px 0; font-size: 18px; border: none; background-color: #13c2c2; color: white; border-radius: 6px; cursor: pointer;">âŸ³ æœè£…</button>
  </div>

  <!-- ç¡®å®šå–æ¶ˆæŒ‰é’® -->
  <div style="display: flex; justify-content: center; gap: 10px; margin-top: 16px;">
    <button onclick="confirmDevice()" style="padding: 8px 16px; background-color: #52c41a; color: white; border: none; border-radius: 6px; cursor: pointer;">ç¡®å®š</button>
    <button onclick="cancelDevice()" style="padding: 8px 16px; background-color: #f5222d; color: white; border: none; border-radius: 6px; cursor: pointer;">å–æ¶ˆ</button>
  </div>

  <!-- è®¾å¤‡é¢„è§ˆ -->
   <div id="devicePreview" style="display:block; margin-top:12px;">
  <img id="preview_arm" style="width:100%; border-radius:8px; margin-top:12px;" />
</div>
 </div>
  </div>

<div style="margin-top: 30px; background: #fffbe6; padding: 20px; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1);">
  <h2 style="margin-top: 0; border-bottom: 2px solid #faad14; padding-bottom: 6px;">ğŸ§ äººæ•°æ£€æµ‹ç»“æœ</h2>

  <div style="display: flex; flex-wrap: wrap; gap: 20px; align-items: center;">
    <!-- å·¦ä¾§æ–‡å­—ä¿¡æ¯ -->
    <div style="flex: 1 1 200px;">
      <p id="resultCount" style="margin: 6px 0; font-size: 16px;">ğŸ‘¥ äººæ•°: -</p>
      <p id="resultConfidence" style="margin: 6px 0; font-size: 16px;">ğŸ¯ ç½®ä¿¡åº¦: -</p>
      <p id="resultTime" style="margin: 6px 0; font-size: 16px;">ğŸ•’ æ—¶é—´: -</p>
    </div>

    <!-- å³ä¾§å›¾ç‰‡ -->
    <div style="flex: 1 1 200px;">
      <img id="resultImage" src="" alt="æ£€æµ‹å›¾åƒ"
     style="max-width: 100%; max-height: 300px; object-fit: contain; border: 1px solid #d9d9d9; border-radius: 6px;" />
    </div>
  </div>
</div>

</section>


</div>
</div>
</div></div></div>
</div></div>
  <h2>å·²ç»‘å®šè®¾å¤‡</h2>
  </div>
</div>
  <div id="deviceContainer"></div>
<div id="controlModal" style="
  display: none;
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.5);
  justify-content: center; align-items: center;
  z-index: 10000;
">
  <div id="controlModalContent" style="
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    max-width: 400px;
    width: 90%;
    position: relative;
  ">
    <button onclick="closeControlModal()" style="
      position: absolute; top: 10px; right: 10px;
      border: none; background: transparent; font-size: 20px;
      cursor: pointer;
    ">&times;</button>

  </div>
</div>


  <!-- è‡ªå®šä¹‰ç¡®è®¤æç¤ºæ¡† -->
  <div id="customPrompt" style="
  display:none; position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.4); z-index:9999; justify-content:center; align-items:center;
  font-family:'Helvetica Neue', sans-serif;">

  <!-- å¼¹å‡ºæ¡†ä¸»ä½“ -->
  <div id="customPromptBox" style="
    background:#fff; padding:20px 25px; border-radius:16px; width:320px;
    box-shadow:0 8px 30px rgba(0,0,0,0.2); text-align:center;">
    
    <div id="customPromptText" style="font-size:16px; color:#333; margin-bottom:20px;">
      æç¤ºå†…å®¹
    </div>
  <button onclick="customPromptResolve(true)" style="
    background:#4CAF50; color:#fff; padding:8px 18px; border:none;
    border-radius:10px; cursor:pointer; font-size:14px; margin-right:10px;">ç¡®å®š</button>
  <button onclick="customPromptResolve(false)" style="
    background:#ccc; color:#333; padding:8px 18px; border:none;
    border-radius:10px; cursor:pointer; font-size:14px;">å–æ¶ˆ</button>
</div>
</div>

  <script>
  let devices = [];
  let bodyPixNet = null;
  let ws;
  let cardMapping = [];  
  let deviceIdToCardIdx = {}; 
  let lastImageMetaId = null;
  let shirts = [];
  let uploader = null;
  let selectedCardIdx = null;
  window.durationData = {};  
  const pendingColors = {};
  const pendingUpdates = [];
  const sceneCanvas = document.getElementById("sceneCanvas");
  const DEFAULT_WS_HOST = '110.41.81.4';
  const host = getHost();
  const mainColorRGB = { r: 255, g: 255, b: 255 };
  document.getElementById('wsServerInput').value = window.location.hostname;
(async () => {
  bodyPixNet = await bodyPix.load();
  console.log('Body-Pix æ¨¡å‹åŠ è½½å®Œæ¯•');
})();

document.getElementById('deviceSelect').addEventListener('change', function() {
  const deviceId = this.value;
  const idx = devices.findIndex(d => d.id === deviceId);
  if (idx < 0) {
    document.getElementById('preview_arm').src = '';
    return;
  }
   const devicePreviewEl = document.getElementById('devicePreview');
  if (deviceId && devicePreviewEl) {
    devicePreviewEl.style.display = 'block';
  } else if (devicePreviewEl) {
    devicePreviewEl.style.display = 'none';
  }
  // ç»‘å®šæœºæ¢°è‡‚æ¨¡å—çš„é¢„è§ˆå›¾åˆ°å¯¹åº”è®¾å¤‡çš„ <img>
  const srcImg = document.getElementById(`preview_${idx}`);
  const armPreview = document.getElementById('preview_arm');

  if (srcImg && armPreview) {
    armPreview.src = srcImg.src; // ç›´æ¥æ˜¾ç¤ºæœ€æ–°ç”»é¢
  }
});


function cancelDevice() {
  document.getElementById('deviceSelect').value = '';

  const devicePreviewEl = document.getElementById('devicePreview');
  if (devicePreviewEl) {
    devicePreviewEl.style.display = 'none';
  }

  const armPreview = document.getElementById('preview_arm');
  if (armPreview) {
    armPreview.src = '';
  }
}


function sendClothUploadState(device) {
  const host = getHost();
  fetch(`http://${host}:3000/devices/${device.id}/clothUpload`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      enabled: true  // âœ”ï¸ å›ºå®š trueï¼Œå› ä¸ºæ˜¯ä¸€æ¬¡æ€§è§¦å‘
    })
  });
}

function sendFlowUploadState(device) {
  const host = getHost();
  fetch(`http://${host}:3000/devices/${device.id}/flowUpload`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      flowUpload: device.flowUpload || false
    })
  });
}


function triggerClothUpload(cardIdx) {
  const device = devices[cardIdx];
  sendClothUploadState(device);
}

function toggleFlowUpload(cardIdx, btn) {
  const device = devices[cardIdx];
  device.flowUpload = !device.flowUpload;
  btn.classList.toggle('active', device.flowUpload);
  sendFlowUploadState(device);
}


let cachedTempVal = 22;
let cachedWeatherType = 'Clear'; // é»˜è®¤æ˜¯æ™´


async function fetchCityTemperature() {
  const select = document.getElementById('citySelect');
  if (!select) return;

  const val = select.value; // æ ¼å¼ "çº¬åº¦,ç»åº¦"
  const [lat, lon] = val.split(',');

  const apiKey = 'bba6207687b9e63191b3a8fdf040bae4'; // æ›¿æ¢æˆè‡ªå·±çš„
  const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${apiKey}`;

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('å¤©æ°”æ¥å£è¯·æ±‚å¤±è´¥');
    const data = await res.json();
    const iconCode = data.weather[0].icon; // ä¾‹å¦‚ "01d"
    let iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
    
    cachedTempVal = data.main.temp;
    cachedWeatherType = data.weather[0].main; // æ¯”å¦‚ "Rain", "Clear", "Snow", "Clouds"
    
      document.getElementById('weatherDisplay').innerHTML =
    `<img src="${iconUrl}" alt="${cachedWeatherType}" style="vertical-align:middle;width:50px;height:50px;margin-right:8px;">
    
     å½“å‰å¤©æ°”ï¼š${cachedWeatherType}`;
  } catch (e) {
    console.error('è·å–å¤©æ°”å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ¸©åº¦å’Œå¤©æ°”', e);
    cachedTempVal = 22 + 5 * Math.sin(Date.now()/100000);
    cachedWeatherType = 'Clear'; // é»˜è®¤å€¼
  }

}
document.getElementById('citySelect').addEventListener('change', fetchCityTemperature);

function drawHeatmap(devices, durationSumMap, dateRangeText) {
  const heatmapCanvas = document.getElementById('heatmapCanvas');
  const ctx = heatmapCanvas.getContext('2d');
  
  ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);

  // å·¦ä¸Šè§’æ˜¾ç¤ºæ—¥æœŸèŒƒå›´æ–‡å­—
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(dateRangeText, 12, 24);  // å·¦ä¸Šè§’

  const sorted = [...devices].sort((a, b) => {
    const aCam = a.type === 'camlamp';
    const bCam = b.type === 'camlamp';
    if (aCam !== bCam) return aCam - bCam;
    return a.idNum - b.idNum;
  });

  const cw = heatmapCanvas.width;
  const lampCount = sorted.length;
  const gap = Math.min(400, cw / (lampCount + 1));
  const totalWidth = (lampCount - 1) * gap;
  const startX = (cw - totalWidth) / 2;

  const values = Object.values(durationSumMap);
  const maxVal = values.length ? Math.max(...values) : 1;

  sorted.forEach((device, i) => {
    const x = startX + i * gap;
    const y = 150;

    const seconds = durationSumMap[device.id] ?? 0;

    const minRadius = 10;
    const maxRadius = 50;
    const radius = minRadius + (seconds / maxVal) * (maxRadius - minRadius);

    const glow = 10 + (radius / maxRadius) * 20;

    ctx.beginPath();
    ctx.shadowColor = `rgba(255, 0, 0, 0.8)`;
    ctx.shadowBlur = glow;
    ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;

    ctx.fillStyle = '#000';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(device.id, x, y + maxRadius + 20);
    ctx.fillText(seconds + ' ç§’', x, y + maxRadius + 40);
  });
  //predictPeople(area, tempVal)
}


function refreshDurationView() {
  const recentDaysVal = document.getElementById('recent-days').value;
  let startDate, endDate;

  if (recentDaysVal) {
    endDate = new Date();
    startDate = new Date();
    startDate.setDate(endDate.getDate() - parseInt(recentDaysVal) + 1);
  } else {
    // å¦‚æœæ²¡æœ‰é€‰æœ€è¿‘Nå¤©ï¼Œå¯ä»¥è‡ªè¡Œå¤„ç†æˆ–è€…è·³è¿‡
    return;
  }
  startDate.setHours(0,0,0,0);
  endDate.setHours(23,59,59,999);

  const result = {};
  for (const id in window.durationData) {
    const dateMap = window.durationData[id];
    let sum = 0;
    for (const dateStr in dateMap) {
      const curDate = new Date(dateStr);
      if (curDate >= startDate && curDate <= endDate) {
        sum += dateMap[dateStr];
      }
    }
    result[id] = sum;
  }

  const dateRangeText = `${formatDate(startDate)} - ${formatDate(endDate)}`;
  drawHeatmap(devices, result, dateRangeText);
  updateDurationTable(result);
}


function formatDate(date) {
  return date.toISOString().split('T')[0]; // YYYY-MM-DD
}

function updateDurationTable(result) {
  const body = document.getElementById('duration-body');
  body.innerHTML = '';

  if (Object.keys(result).length === 0) {
    body.innerHTML = '<tr><td colspan="2">æ— æ•°æ®</td></tr>';
  } else {
    for (const id in result) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${id}</td><td>${result[id]}</td>`;
      body.appendChild(tr);
    }
  }
}


function queryDuration() {
  const startStr = document.getElementById('start-date').value;
  const endStr = document.getElementById('end-date').value;
  const recentDaysVal = document.getElementById('recent-days').value;

  let startDate, endDate;

  if (recentDaysVal) {
  endDate = new Date();
  startDate = new Date();
  startDate.setDate(endDate.getDate() - parseInt(recentDaysVal) + 1);

  // æŠŠæ—¶åˆ†ç§’æ¸…é›¶
  startDate.setHours(0,0,0,0);
  endDate.setHours(23,59,59,999);

  document.getElementById('start-date').value = '';
  document.getElementById('end-date').value = '';
 } else {
  if (!startStr || !endStr) {
    alert('è¯·é€‰æ‹©èµ·å§‹å’Œç»“æŸæ—¥æœŸ');
    return;
  }
  startDate = new Date(startStr);
  endDate = new Date(endStr);

  // åŒæ ·æ¸…é›¶æ—¶åˆ†ç§’
  startDate.setHours(0,0,0,0);
  endDate.setHours(23,59,59,999);

  if (startDate > endDate) {
    alert('èµ·å§‹æ—¥æœŸä¸èƒ½æ™šäºç»“æŸæ—¥æœŸ');
    return;
  }

  document.getElementById('recent-days').value = '';
 }

  const dateRangeText = `${formatDate(startDate)} - ${formatDate(endDate)}`;

  const result = {};
  for (const id in window.durationData) {
    const dateMap = window.durationData[id];
    let sum = 0;
    for (const dateStr in dateMap) {
      const curDate = new Date(dateStr);
      if (curDate >= startDate && curDate <= endDate) {
        sum += dateMap[dateStr];
      }
    }
    result[id] = sum;
  }

  const table = document.getElementById('duration-result');
  updateDurationTable(result);
  drawHeatmap(devices, result, dateRangeText);
}


document.getElementById('start-date').addEventListener('change', () => {
  document.getElementById('recent-days').value = "";
});

document.getElementById('end-date').addEventListener('change', () => {
  document.getElementById('recent-days').value = "";
});


function selectSceneCard(el, tempValue) {
  document.querySelectorAll('.side-card').forEach(card => card.classList.remove('active'));
  el.classList.add('active');

  applyScene(tempValue, { immediate: true });
}

let sceneLoopTimer = null;


function startColorTempLoop(options = {}) {
  clearInterval(sceneLoopTimer);
  stopAutoLuxLoop();
  // åˆå§‹åŒ–æ¯ä¸ªè®¾å¤‡è‰²æ¸©å’Œæ­¥é•¿ï¼Œä¿è¯é—´éš”å›ºå®š
  devices.forEach((dev, idx) => {
    dev.temp = 2700 + idx * 0;  // åŸºå‡†3500Kï¼Œè®¾å¤‡é—´éš”400K
    dev.tempStep = 100;            // åˆå§‹æ­¥é•¿å‘ä¸Šé€’å¢
  });

  sceneLoopTimer = setInterval(() => {
    devices.forEach((dev, idx) => {
      dev.temp += dev.tempStep;

      if (dev.temp >= 6500) {
        dev.temp = 6500;
        dev.tempStep = -Math.abs(dev.tempStep);
      } else if (dev.temp <= 2700) {
        dev.temp = 2700;
        dev.tempStep = Math.abs(dev.tempStep);
      }

      dev.auto = false;

      const cardIdx = Object.keys(cardMapping).find(key => cardMapping[key] == idx);
      if (cardIdx != null) {
        const n = Number(cardIdx);
        document.querySelector(`#device_card_${n} input[type="checkbox"]`).checked = false;
        document.getElementById(`tempSlider_${n}`).disabled = false;
        document.getElementById(`tempSlider_${n}`).value = dev.temp;
        document.getElementById(`currentTemp_${n}`).textContent = dev.temp;

        updateTemp(n, dev.temp, { immediate: true, ...options });
      }
    });
  }, 100);
}


function stopColorTempLoop() {
  clearInterval(sceneLoopTimer);
  sceneLoopTimer = null;
}

function toggleColorTempLoop(cardElement) {
  const isActive = cardElement.classList.contains("active");
  document.querySelectorAll('.side-card').forEach(card => card.classList.remove('active'));
  if (isActive) {
    stopColorTempLoop();
    cardElement.classList.remove("active");
  } else {
    startColorTempLoop();
    cardElement.classList.add("active");
  }
}



function applyScene(tempValue, options = {}) {
    stopColorTempLoop();
    stopAutoLuxLoop();
  
  devices.forEach((dev, realIdx) => {
    dev.auto = false;
    dev.temp = tempValue;

    const cardIdx = Object.keys(cardMapping).find(
      key => cardMapping[key] == realIdx
    );

    if (cardIdx != null) {
      const n = Number(cardIdx);

      // âœ… åŒæ­¥ UI
      document.querySelector(`#device_card_${n} input[type="checkbox"]`).checked = false;
      document.getElementById(`tempSlider_${n}`).disabled = false;
      document.getElementById(`tempSlider_${n}`).value = tempValue;
      document.getElementById(`currentTemp_${n}`).textContent = tempValue;

      // âœ… ä¼ å…¥ optionsï¼ˆè®© immediate: true ç”Ÿæ•ˆï¼‰
      updateTemp(n, tempValue, options);
    } else {
      console.warn(`[applyScene] è·³è¿‡è®¾å¤‡ ${dev.id}ï¼ˆæ—  cardIdx æ˜ å°„ï¼‰`);
    }
  });
}

function stopAutoLuxLoop() {
  if (luxAutoTimer) {
    clearInterval(luxAutoTimer);
    luxAutoTimer = null;
  }
}

function getBrightnessFromLux(lux) {
  const maxLux = 5000;
  const minBrightness = 30;
  const maxBrightness = 100;

  const clampedLux = Math.min(Math.max(lux, 0), maxLux); // é™å®šèŒƒå›´ 0~7000
  const ratio = clampedLux / maxLux;                     // æ˜ å°„åˆ° 0~1
  const brightness = maxBrightness - (maxBrightness - minBrightness) * ratio;
  return Math.round(brightness);
}
let luxAutoTimer = null; // ç¡®ä¿åœ¨å¤–éƒ¨å®šä¹‰ï¼Œå…¨å±€å¯æ§åˆ¶

function selectAutoMode(el) {
  const isActive = el.classList.contains("active");

  // å…ˆæ¸…é™¤æ‰€æœ‰å¡ç‰‡æ¿€æ´»çŠ¶æ€
  document.querySelectorAll('.side-card').forEach(card => card.classList.remove('active'));

  if (isActive) {
    // å¦‚æœå·²ç»æ¿€æ´»ï¼Œç‚¹å‡»åˆ™åœæ­¢è‡ªåŠ¨æ¨¡å¼
    stopColorTempLoop();
    if (luxAutoTimer) {
      clearInterval(luxAutoTimer);
      luxAutoTimer = null;
    }
    el.classList.remove("active");
  } else {
    // æ¿€æ´»è‡ªåŠ¨æ¨¡å¼
    el.classList.add("active");
    stopColorTempLoop(); // åœæ­¢å…¶ä»–å¾ªç¯
    if (luxAutoTimer) clearInterval(luxAutoTimer); // é˜²æ­¢é‡å¤å®šæ—¶å™¨

    luxAutoTimer = setInterval(() => {
      const lux = latestLux ?? 0;
      const brightness = getBrightnessFromLux(lux);

      // è·å–åº—é“ºç±»å‹
      const select = document.getElementById('storeTypeSelect');
      const [storeType] = select.value.split(','); // åªå–ç±»å‹

      let tempValue = 4000; // é»˜è®¤è‰²æ¸©
      if (storeType === 'é«˜ç«¯') tempValue = 3500;
      else if (storeType === 'ä¸­ç«¯') tempValue = 4000;
      else if (storeType === 'å°å‹') tempValue = 5000;

      devices.forEach((dev, realIdx) => {
        dev.auto = true;

        const cardIdx = Object.keys(cardMapping).find(
          key => cardMapping[key] === realIdx
        );

        if (cardIdx != null) {
          const n = Number(cardIdx);

          // æ›´æ–°æ»‘å—æ˜¾ç¤º
          const tmpSlider = document.getElementById(`tempSlider_${n}`);
          tmpSlider.value = dev.recommendedTemp;
          tmpSlider.disabled = true;

          const briSlider = document.getElementById(`brightnessSlider_${n}`);
          briSlider.value = dev.recommendedBrightness;
          briSlider.disabled = true;

          // å®é™…è®¾å¤‡èµ‹å€¼
          dev.temp = tempValue;
          dev.brightness = brightness;

          // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬
          document.getElementById(`currentTemp_${n}`).textContent = dev.recommendedTemp;
          document.getElementById(`currentBrightness_${n}`).textContent = dev.recommendedBrightness;

          // ç«‹å³å‘é€æ›´æ–°
          updateTemp(n, tempValue, {});
          updateBrightness(n, brightness, { immediate: true });
        } else {
          console.warn(`[selectAutoMode] è·³è¿‡è®¾å¤‡ ${dev.id}ï¼ˆæ—  cardIdx æ˜ å°„ï¼‰`);
        }
      });
    }, 300);
  }
}



function openControlModal(cardIdx) {
  const originalCard = document.getElementById(`device_card_${cardIdx}`);
  const modalBg      = document.getElementById("controlModal");
  const modalContent = document.getElementById("controlModalContent");
  const closeBtn = modalContent.querySelector("button");

  modalContent.innerHTML = "";
  modalContent.appendChild(closeBtn);

  const clone = originalCard.cloneNode(true);
  modalContent.appendChild(clone);
  modalBg.style.display = "flex";


  const bSl = clone.querySelector(`#brightnessSlider_${cardIdx}`);
  const bTxt = clone.querySelector(`#currentBrightness_${cardIdx}`);
  bSl.addEventListener("input", e => {
    updateBrightness(cardIdx, e.target.value);
    bTxt.innerText = e.target.value + "%";
  });

  const tSl = clone.querySelector(`#tempSlider_${cardIdx}`);
  const tTxt = clone.querySelector(`#currentTemp_${cardIdx}`);
  tSl.addEventListener("input", e => {
    updateTemp(cardIdx, e.target.value);
    tTxt.innerText = e.target.value + "K";
  });

 const chk = clone.querySelector(`input[type=checkbox]`);
  if (chk) {
    chk.addEventListener("change", e => {
      const isAuto = e.target.checked;
      // å…ˆåŒæ­¥åˆ°æ•°æ®å’ŒåŸå¡ç‰‡
      toggleAuto(cardIdx, isAuto);
      // å†ç¦/å¯ç”¨ modal é‡Œçš„æ»‘å—
      bSl.disabled = isAuto;
      tSl.disabled = isAuto;
    });
  }
  const fileInput = clone.querySelector("input[type=file]");
if (fileInput) {
  const newInput = fileInput.cloneNode();  
  fileInput.replaceWith(newInput);      

  newInput.addEventListener("change", ev => {
    processImageFile(ev, cardIdx);
    setTimeout(() => {
      const box = clone.querySelector(".color-box");
      const d   = devices[cardMapping[cardIdx]];
      box.style.background = d.mainColorRGB;
      box.innerText        = d.mainColorRGB;
      const [r,g,b] = d.mainColorRGB.match(/\d+/g).map(Number);
      const lum = 0.299*r + 0.587*g + 0.114*b;
      box.style.color = lum>186 ? "#000" : "#fff";
    }, 500);
  });
}
}

function closeControlModal() {
  document.getElementById("controlModal").style.display = "none";
}

function getHost() {
    const input = document.getElementById('wsServerInput').value.trim();
    if (input) return input;
    if (window.location.hostname) return window.location.hostname;
    return DEFAULT_WS_HOST;
  }

function handleWsMessage(evt) {
  if (evt.data instanceof Blob) {
    const cardIdx = deviceIdToCardIdx[lastImageMetaId];
    if (cardIdx == null) {
      console.warn('æ— æ³•å®šä½ cardIdx for', lastImageMetaId);
      return;
    }

    const imgEl = document.getElementById(`preview_${cardIdx}`);
    if (!imgEl) {
      console.warn('æ²¡æ‰¾åˆ° preview å…ƒç´  preview_' + cardIdx);
      return;
    }

    const objectUrl = URL.createObjectURL(evt.data);
    imgEl.src = objectUrl;
    setTimeout(() => URL.revokeObjectURL(objectUrl), 5000);
    return;
  }
  
  if (typeof evt.data === 'string') {
    let msg;
    try { msg = JSON.parse(evt.data); }
    catch { return; }
    if (msg.type === 'image/jpeg') {
      lastImageMetaId = msg.id;
      return;
    }

    if (msg.type === 'state') {
      // console.log('æ”¶åˆ° state æ¶ˆæ¯:', msg);
  updateDeviceUI(msg);

  return;
 }

 if (msg.type === 'personDetection') {
  console.log('æ”¶åˆ°äººæ•°æ£€æµ‹ç»“æœ:', msg.data);

  const count = msg.data.count;
  const confidence = msg.data.confidence;
  const timestamp = msg.data.timestamp;
  const imgBase64 = msg.data.annotated_image_base64;

  console.log(`äººæ•°: ${count}, ç½®ä¿¡åº¦: ${confidence}, æ—¶é—´: ${timestamp}`);

  // æ˜¾ç¤ºäººæ•°ã€ç½®ä¿¡åº¦ã€æ—¶é—´
  document.getElementById('resultCount').innerText = `äººæ•°: ${count}`;
  document.getElementById('resultConfidence').innerText = `ç½®ä¿¡åº¦: ${confidence}`;
  document.getElementById('resultTime').innerText = `æ—¶é—´: ${timestamp}`;

  // å¦‚æœæœ‰ base64 å›¾åƒï¼Œæ›´æ–°å›¾ç‰‡
  if (imgBase64) {
    const imgElem = document.getElementById('resultImage');
    if (imgElem) {
      imgElem.src = 'data:image/jpeg;base64,' + imgBase64;
    }
  }
}

  if (msg.type === "lux") {
   latestLux = msg.value;
      const luxContainer = document.getElementById("luxDisplay");
      if (luxContainer) {
        luxContainer.innerHTML = `
          <strong>ğŸ’¡ å…‰ç…§å€¼ï¼š</strong> ${msg.value} lux <br>
          <span style="color:gray;font-size:0.9em;">æ›´æ–°æ—¶é—´ï¼š${new Date(msg.time).toLocaleString()}</span>
        `;
      }
    }
    if (msg.type === 'image') {
      const cardIdx = deviceIdToCardIdx[msg.id];
      const imgEl = document.getElementById(`preview_${cardIdx}`);
      if (imgEl) imgEl.src = 'data:image/jpeg;base64,' + msg.data;
    }
    if (msg.type === 'durationUpdate') {
  window.durationData = msg.data || {};
  // æ ¹æ®æœ€è¿‘Nå¤©é€‰æ‹©ï¼Œé‡æ–°è®¡ç®—å¹¶æ›´æ–°æ˜¾ç¤º
  const recentDaysVal = document.getElementById('recent-days').value;
  if (recentDaysVal) {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - parseInt(recentDaysVal) + 1);
    startDate.setHours(0,0,0,0);
    endDate.setHours(23,59,59,999);

    const result = {};
    for (const id in window.durationData) {
      const dateMap = window.durationData[id];
      let sum = 0;
      for (const dateStr in dateMap) {
        const curDate = new Date(dateStr);
        if (curDate >= startDate && curDate <= endDate) {
          sum += dateMap[dateStr];
        }
      }
      result[id] = sum;
    }

    const dateRangeText = `${formatDate(startDate)} - ${formatDate(endDate)}`;
    drawHeatmap(devices, result, dateRangeText);
    updateDurationTable(result);
  }
    }}
  
}



function initWebSocket() {
  const host = getHost();
  console.log(`ğŸš€ å‡†å¤‡è¿æ¥ WS â†’ ws://${host}:8081`);
  ws = new WebSocket(`ws://${host}:8081`);
  ws.binaryType = 'blob';
  ws.onopen    = () => console.log('âœ… WS å·²è¿æ¥');
  ws.onmessage = handleWsMessage;
  ws.onerror   = e => console.error('ğŸ›‘ WS é”™è¯¯ï¼š', e);
  ws.onclose   = () => {
    console.warn('ğŸ”Œ WS æ–­å¼€ï¼Œ5 ç§’åé‡è¿');
    setTimeout(initWebSocket, 5000);
  };
}


function updateDeviceUI(msg) {
  const cardIdx = deviceIdToCardIdx[msg.id];
  if (cardIdx == null || !document.getElementById(`device_card_${cardIdx}`)) {
    pendingUpdates.push(msg);
    return;
  }

  const realIdx = cardMapping[cardIdx];
  const d = devices[realIdx];

  // 2. åŒæ­¥æ‰€æœ‰å­—æ®µâ€”â€”åŒ…æ‹¬å½“å‰å€¼å’Œæ¨èå€¼
  d.brightness             = Number(msg.brightness ?? d.brightness);
  d.temp                   = Number(msg.temp       ?? d.temp);
  d.recommendedBrightness  = Number(msg.recommendedBrightness  ?? d.recommendedBrightness);
  d.recommendedTemp        = Number(msg.recommendedTemp        ?? d.recommendedTemp);
  d.auto                   = Boolean(msg.auto);
  if (msg.mainColorRGB)    d.mainColorRGB = msg.mainColorRGB;
  if (msg.fabric)          d.fabric       = msg.fabric;

  // 3. åŒæ­¥ UI æ§ä»¶
  const bSl  = document.getElementById(`brightnessSlider_${cardIdx}`);
  const tSl  = document.getElementById(`tempSlider_${cardIdx}`);
  const chk  = document.querySelector(`#device_card_${cardIdx} input[type=checkbox]`);
  if (chk) chk.checked = d.auto;

  if (bSl) {
    bSl.disabled = d.auto;
    // è‡ªåŠ¨æ¨¡å¼æ˜¾ç¤ºæ¨èå€¼ï¼Œå¦åˆ™æ˜¾ç¤ºå½“å‰å€¼
    bSl.value    = d.auto ? d.recommendedBrightness : d.brightness;
  }
  if (tSl) {
    tSl.disabled = d.auto;
    tSl.value    = d.auto ? d.recommendedTemp : d.temp;
  }

  // 4. æ›´æ–°æ–‡å­—æ˜¾ç¤ºï¼ˆè‡ªåŠ¨ç”± updateDisplay é€‰å€¼ï¼‰
  updateDisplay(cardIdx);

  // 5. æ›´æ–°é¢æ–™æ ‡ç­¾
  const fabricBox = document.getElementById(`fabricLabel_${cardIdx}`);
  if (fabricBox) {
    fabricBox.innerText = `é¢æ–™: ${d.fabric ?? 'æœªçŸ¥'}`;
  }

  // 6. æ›´æ–°ä¸»è‰²å—
  const colorBox = document.getElementById(`colorBox_${cardIdx}`);
  if (colorBox && d.mainColorRGB) {
    const { r, g, b } = d.mainColorRGB;
    const rgbStr = `rgb(${r},${g},${b})`;
    colorBox.style.background = rgbStr;
    colorBox.innerText        = rgbStr;
    const lum = 0.299*r + 0.587*g + 0.114*b;
    colorBox.style.color = lum > 186 ? '#000' : '#fff';
  }
  // 7. é‡ç»˜å…‰æ•ˆ
  if (msg.mainColorRGB) {
  d.mainColorRGB = msg.mainColorRGB;
  // ä¸»è‰²ä¹Ÿå†™å…¥ shirts
   if (shirts && shirts[realIdx]) {
    shirts[realIdx].color = msg.mainColorRGB;
  }
  drawScene();
}
}


window.addEventListener('load', async () => {
  initWebSocket();
  fetchCityTemperature();
  setInterval(fetchCityTemperature, 10 * 60 * 1000);           
  await loadAndRenderDevices();  
  for (const msg of pendingUpdates) {
    updateDeviceUI(msg);         
  }
  pendingUpdates.length = 0;
});

  let statusTimer = null;
  
function renderDevices() {
  const container = document.getElementById("deviceContainer");
  container.innerHTML = "";
  cardMapping = []; 
  Object.keys(deviceIdToCardIdx).forEach(k => delete deviceIdToCardIdx[k]);
  const sortedDevices = [...devices].sort((a, b) => {
    const isCamA = a.id.toLowerCase().startsWith("camlamp");
    const isCamB = b.id.toLowerCase().startsWith("camlamp");
    if (isCamA !== isCamB) return isCamA - isCamB;

    const numA = parseInt(a.id.match(/\d+/));
    const numB = parseInt(b.id.match(/\d+/));
    return (isNaN(numA) ? 0 : numA) - (isNaN(numB) ? 0 : numB);
  });

  sortedDevices.forEach((device, cardIdx) => {
    const realIdx = devices.findIndex(d => d.id === device.id);
    cardMapping[cardIdx] = realIdx;
    deviceIdToCardIdx[device.id] = cardIdx;
    const div = document.createElement("div");
    div.className = "lamp-card";
    div.id = `device_card_${cardIdx}`;
    let uploadHtml = '';
    if (device.id.toLowerCase().startsWith('camlamp')) {
      uploadHtml = `
        <div style="margin-top:12px;">
          <div style="font-size:14px; color:#606266;">å®æ—¶é¢„è§ˆï¼š</div>
          <img id="preview_${cardIdx}" 
               src="" 
               style="width:100%; border-radius:8px; margin-top:6px;"
          />
        </div>`;
    }
    div.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0;">${device.id} (${device.ip})</h3>
        <span id="status_${cardIdx}" style="font-size: 13px; color: #666;">ğŸŸ¡ æ£€æŸ¥ä¸­...</span>
      </div>
      <div class="status-line">
  <span id="lastseen_${cardIdx}" style="margin-left: 12px; font-size: 0.9em; color: gray;"></span>
</div>


  ${uploadHtml}
        <div style="position: relative; margin-top: 10px;">
    <label>äº®åº¦: <span id="currentBrightness_${cardIdx}">${device.brightness}</span></label>
    <input
      type="range"
      id="brightnessSlider_${cardIdx}"
      min="0" max="100"
      value="${device.brightness}"
      ${device.auto ? 'disabled' : ''}
      oninput="updateBrightness(${cardIdx}, this.value); updateDisplay(${cardIdx});"
    >
  </div>

  <div style="position: relative; margin-top: 10px;">
    <label>è‰²æ¸©: <span id="currentTemp_${cardIdx}">${device.temp}</span></label>
    <input
      type="range"
      id="tempSlider_${cardIdx}"
      min="2700" max="6500" step="100"
      value="${device.temp}"
      ${device.auto ? 'disabled' : ''}
      oninput="updateTemp(${cardIdx}, this.value); updateDisplay(${cardIdx});"
    >
  </div>

<div class="color-box" id="colorBox_${cardIdx}">
  ${
    device.mainColorRGB
      ? `rgb(${device.mainColorRGB.r},${device.mainColorRGB.g},${device.mainColorRGB.b})`
      : 'æœªæå–'
  }
</div>

<div class="fabric-label" id="fabricLabel_${cardIdx}">
  é¢æ–™: ${device.fabric || 'æœªçŸ¥'}
</div>
  <label style="display:block; margin-top: 8px;">
    <input
      type="checkbox"
      ${device.auto ? 'checked' : ''}
      onchange="toggleAuto(${cardIdx}, this.checked)"
    > è‡ªåŠ¨æ¨¡å¼
  </label>

   ${ device.id.toLowerCase().startsWith('lamp')
  ? `
    <label style="display:block; margin-top:12px; font-size:13px; color:#606266;">ä¸Šä¼ è¡£æœå›¾ç‰‡ï¼ˆè‡ªåŠ¨è¯†åˆ«ä¸»è‰²å¹¶è°ƒæ•´ï¼‰</label>
    <label class="upload-btn-wrapper">
      é€‰æ‹©æ–‡ä»¶
      <input
        type="file"
        accept="image/*"
        onchange="processImageFile(event, ${cardIdx})"
      />
    </label>
  `
  : ``
}

${
  device.id.toLowerCase().startsWith('camlamp')
  ? `
    <div style="margin-top:12px; display:flex; gap:8px;">
      <button
        class="detect-upload-btn"
        onclick="triggerClothUpload(${cardIdx})"
      >æœè£…åˆ†æ</button>

      <button
        id="flowUploadBtn_${cardIdx}"
        class="flow-upload-btn"
        onclick="toggleFlowUpload(${cardIdx}, this)"
      >äººæµç›‘æµ‹</button>
    </div>
  `
  : ``
}


<label class="btn-delete" style="cursor:pointer;">
        åˆ é™¤è®¾å¤‡
      </label>
    `;

  container.appendChild(div);

  const delBtn = div.querySelector('.btn-delete');
  delBtn.addEventListener('click', () => removeDevice(realIdx));
});
devices.forEach(msg => {
  updateDeviceUI(msg);
});

checkAllDevicesOnline();

/*
if (statusTimer) clearInterval(statusTimer);
statusTimer = setInterval(() => {
  cardMapping.forEach((realIdx, cardIdx) => {
    checkDeviceOnline(realIdx, cardIdx);
  });
}, 10000);*/
if (statusTimer) clearInterval(statusTimer);
statusTimer = setInterval(() => {
  checkAllDevicesOnline(); // æ›¿æ¢åŸforEachå¾ªç¯è°ƒç”¨
}, 10000);
}

function addDevice(id, ip) {
  const newDevice = {
    id, ip, temp: 4000, brightness: 80, auto: true};
  const host = getHost();

fetch(`http://${host}:3000/devices`, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(newDevice)
})
.then(res => {
  if (!res.ok) throw new Error("è®¾å¤‡é‡å¤");
  return res.json();
})
.then(({ device }) => {
  devices.push(device);
  renderDevices();
  drawScene();
})
.catch(err => alert("æ·»åŠ å¤±è´¥ï¼š" + err.message));

}


function showAddDeviceModal() {
  document.getElementById("addDeviceModal").style.display = "flex";
}

function hideAddDeviceModal() {
  document.getElementById("addDeviceModal").style.display = "none";
}

function removeDevice(cardIdx) {
  const realIdx = cardMapping[cardIdx];
  const device = devices[cardIdx];
  const id   = device.id;
  const ip   = device.ip;
  const host = getHost();

  // å‘æœåŠ¡å™¨å‘é€ DELETE è¯·æ±‚
  fetch(`http://${host}:3000/devices/${id}`, { method: "DELETE" })
    .then(res => {
      if (!res.ok) throw new Error("æœåŠ¡å™¨åˆ é™¤å¤±è´¥");

      console.log(`âœ… è®¾å¤‡ ${id} å·²ä»æœåŠ¡å™¨ç§»é™¤`);

      fetch(`http://${ip}/resumeBroadcast`).catch(() => {
        console.warn(`âš ï¸ é€šçŸ¥ ${id} æ¢å¤å¹¿æ’­å¤±è´¥`);
      });

      // ä»å®¢æˆ·ç«¯åˆ—è¡¨ç§»é™¤å¹¶é‡ç»˜
      devices.splice(cardIdx, 1);
      renderDevices();
      drawScene();
    })
    .catch(err => alert("âŒ åˆ é™¤å¤±è´¥ï¼š" + err.message));
}

let scanWs;
let scanTimer = null;
async function startDeviceScan() {
  document.getElementById("scanStatus").innerText = "ğŸ” æ­£åœ¨æ‰«æè®¾å¤‡ä¸­ï¼Œè¯·ç¨å€™...";
  await loadAndRenderDevices();
  drawScene();
  const hostInput = document.getElementById('wsServerInput').value.trim();
  const host = getHost();
  const url = `ws://110.41.81.4:8081`;
  if (ws && ws.readyState === WebSocket.OPEN) {
  }
  scanWs = new WebSocket(url)
 
 scanWs.onopen = () => {
   
  console.log('å·²è¿æ¥åˆ°UDPè½¬å‘æœåŠ¡å™¨ï¼ˆå¼€å§‹æ‰«æï¼‰');
  document.querySelector("button[onclick='startDeviceScan()']").disabled = true;
  // 10ç§’åè‡ªåŠ¨åœæ­¢æ‰«æ
  scanTimer = setTimeout(() => {
    stopDeviceScan();  
    showCustomPrompt("â±ï¸ æ‰«æè¶…æ—¶ï¼Œæ˜¯å¦æ‰‹åŠ¨æ·»åŠ è®¾å¤‡ï¼Ÿ").then((manual) => {
    if (manual) {
      showAddDeviceModal(); 
    }
  });
  }, 10000);
};

  scanWs.onerror = (err) => {
  console.error("WebSocket è¿æ¥å‡ºé”™ï¼š", err);
  stopDeviceScan();

  showCustomPrompt("âŒ æ— æ³•è¿æ¥åˆ°ï¼Œè¯·æ£€æŸ¥ UDP æœåŠ¡æ˜¯å¦å¼€å¯ï¼Œæˆ–æ‰‹åŠ¨è¾“å…¥IPã€‚<br>æ˜¯å¦æ‰‹åŠ¨æ·»åŠ è®¾å¤‡ï¼Ÿ")
    .then((manual) => {
      if (manual) {
        showAddDeviceModal(); 
      } 
    });
};



scanWs.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  console.log('WS æ”¶åˆ°æ¶ˆæ¯ï¼š', msg);
  // durationæ•°æ®æ›´æ–°å¤„ç†
    if (msg.type === 'durationUpdate') {
      window.durationData = msg.data || {};
      console.log('æ”¶åˆ° duration å…¨é‡æ•°æ®:', window.durationData);
    }
  // 1) è®¾å¤‡å¹¿æ’­
  if (msg.type === 'announce') {
    clearTimeout(scanTimer);
    showCustomPrompt(`å‘ç°è®¾å¤‡ï¼š${msg.id} (${msg.ip})<br>æ˜¯å¦æ·»åŠ ï¼Ÿ`)
      .then(confirmAdd => {
        if (confirmAdd) addDevice(msg.id, msg.ip);
        stopDeviceScan();
      });
    return;
  }
  if (msg.type === "lux") {
      const luxContainer = document.getElementById("luxDisplay");
      if (luxContainer) {
        luxContainer.innerHTML = `
          <strong>ğŸ’¡ å…‰ç…§å€¼ï¼š</strong> ${msg.value} lux <br>
          <span style="color:gray;font-size:0.9em;">æ›´æ–°æ—¶é—´ï¼š${new Date(msg.time).toLocaleString()}</span>
        `;
      }
    }
  // 2) å›¾ç‰‡æ•°æ®
  if (msg.type === 'image') {
    const idx = devices.findIndex(d => d.id === msg.id);
    if (idx < 0) return;
    const d = devices[idx];
    const imgEl = document.getElementById(`preview_${idx}`);
    // åŒæ­¥ä¸€ä¸‹äº®åº¦/æ¸©åº¦æ»‘æ¡åˆ° d é‡Œ
    document.getElementById(`brightnessSlider_${idx}`).value = d.brightness;
    document.getElementById(`tempSlider_${idx}`).value       = d.temp;
    if (imgEl) {
      imgEl.src = 'data:image/jpeg;base64,' + msg.data;
    }
    return;
  }

  // 3) çŠ¶æ€æ›´æ–°
  if (msg.type === 'state') {
    const idx = devices.findIndex(d => d.id === msg.id);
    if (idx < 0) return;
    const d = devices[idx];

    // â€”â€” æ›´æ–°æ•°æ®æ¨¡å‹ â€”â€”  
    d.brightness            = Number(msg.brightness ?? d.brightness);
    d.temp                  = Number(msg.temp       ?? d.temp);
    d.recommendedBrightness = Number(msg.recommendedBrightness ?? d.recommendedBrightness);
    d.recommendedTemp       = Number(msg.recommendedTemp       ?? d.recommendedTemp);
    d.auto                  = Boolean(msg.auto);
    d.fabric                = msg.fabric;
    if (msg.mainColorRGB) {
      d.mainColorRGB = msg.mainColorRGB;
      pendingColors[idx] = d.mainColorRGB;
      if (shirts && shirts[idx]) {
        shirts[idx].color = d.mainColorRGB;
      }
    }
    if (msg.fabric) {
      d.fabric = msg.fabric;
    }

    // â€”â€” åŒæ­¥ UI â€”â€”  
    const bSl     = document.getElementById(`brightnessSlider_${idx}`);
    const tSl     = document.getElementById(`tempSlider_${idx}`);
    const autoChk = document.getElementById(`autoCheckbox_${idx}`);
    if (autoChk) autoChk.checked = d.auto;

    if (bSl) {
      bSl.disabled = d.auto;
      bSl.value    = d.auto ? d.recommendedBrightness : d.brightness;
    }
    if (tSl) {
      tSl.disabled = d.auto;
      tSl.value    = d.auto ? d.recommendedTemp : d.temp;
    }

    // æ–‡æœ¬æ˜¾ç¤º è‡ªåŠ¨/æ‰‹åŠ¨ è‡ªåŠ¨é€‰æ‹©æ¨èå€¼æˆ–å½“å‰å€¼
    updateDisplay(idx);

    // é¢æ–™æ ‡ç­¾
    const fabricBox = document.getElementById(`fabricLabel_${idx}`);
    if (fabricBox && d.fabric) {
      fabricBox.innerText = `é¢æ–™: ${d.fabric}`;
    }

    // é¢œè‰²æ¡†
    const box = document.getElementById(`colorBox_${idx}`);
    if (box && d.mainColorRGB) {
      const { r, g, b } = d.mainColorRGB;
      const rgbStr = `rgb(${r},${g},${b})`;
      box.style.background = rgbStr;
      box.innerText        = rgbStr;
      const lum = 0.299*r + 0.587*g + 0.114*b;
      box.style.color = lum > 186 ? '#000' : '#fff';
    }
    drawScene();
    return;
  }

};


scanWs.onclose = () => {
    ws = null;
    clearTimeout(scanTimer);
    document.getElementById("scanStatus").innerText = "";
  };
}

function debounce(fn, delay = 200) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn(...args);    
      drawScene();    
    }, delay);
  };
}

const debouncedSend = debounce(send, 200);

function stopDeviceScan() {
  if (scanWs) {
    scanWs.close();
    scanWs = null;
    clearTimeout(scanTimer);
    document.getElementById("scanStatus").innerText = "";
    document.querySelector("button[onclick='startDeviceScan()']").disabled = false;
  }
}

function confirmAddDevice() {
  const id = document.getElementById("modalId").value.trim();
  const ip = document.getElementById("modalIp").value.trim();

  if (!id || !ip) {
    alert("è¯·å¡«å†™å®Œæ•´çš„è®¾å¤‡ ID å’Œ IPï¼");
    return;
  }

  addDevice(id, ip);   
  hideAddDeviceModal(); 
  drawScene();
}

let customPromptCallback = null;

function showCustomPrompt(text) {
  return new Promise((resolve) => {
    const box = document.getElementById("customPrompt");
    const dialog = document.getElementById("customPromptBox"); 

    document.getElementById("customPromptText").innerHTML = text;
    box.style.display = "flex";

    dialog.classList.remove("hide");
    dialog.classList.add("show");

    customPromptCallback = resolve;
  });
}

function customPromptResolve(result) {
  const box = document.getElementById("customPrompt");
  const dialog = document.getElementById("customPromptBox");

  dialog.classList.remove("show");
  dialog.classList.add("hide");

  setTimeout(() => {
    box.style.display = "none";
    customPromptCallback?.(result);
    customPromptCallback = null;
  }, 200); 
}

function formatTimestamp(ts) {
  const d = new Date(ts);
  return d.toLocaleString();


}

function checkDeviceOnline(realIdx, cardIdx) {
  const device = devices[realIdx];
  const serverHost = "110.41.81.4";

  fetch(`http://${serverHost}:3000/onlineDevices`)
    .then(res => res.json())
    .then(data => {
      const entry = data[device.id];
      const isOnline = entry && entry.online;
      const timeStr = entry && entry.lastSeen ? formatTimestamp(entry.lastSeen) : "æœªçŸ¥";

      if (isOnline) {
        document.getElementById(`status_${cardIdx}`).innerText = "ğŸŸ¢ åœ¨çº¿";
        document.getElementById(`lastseen_${cardIdx}`).innerText = ``;
      } else {
        document.getElementById(`status_${cardIdx}`).innerText = "ğŸ”´ ç¦»çº¿";
        document.getElementById(`lastseen_${cardIdx}`).innerText = `ä¸Šæ¬¡åœ¨çº¿ï¼š${timeStr}`;
      }
    })
    .catch(() => {
      document.getElementById(`status_${cardIdx}`).innerText = "âš ï¸ ç½‘ç»œé”™è¯¯";
      document.getElementById(`lastseen_${cardIdx}`).innerText = "";
    });
}

function checkAllDevicesOnline() {
  const serverHost = "110.41.81.4";
  
  // åªå‘èµ·1æ¬¡è¯·æ±‚ï¼Œè·å–æ‰€æœ‰è®¾å¤‡çŠ¶æ€
  fetch(`http://${serverHost}:3000/onlineDevices`)
    .then(res => res.json())
    .then(allDevicesData => {
      // éå†æ‰€æœ‰è®¾å¤‡å¡ç‰‡ï¼Œæ‰¹é‡æ›´æ–°UI
      cardMapping.forEach((realIdx, cardIdx) => {
        const device = devices[realIdx]; // å½“å‰è®¾å¤‡ä¿¡æ¯
        const entry = allDevicesData[device.id]; // ä»å…¨å±€æ•°æ®ä¸­åŒ¹é…å½“å‰è®¾å¤‡
        const isOnline = entry && entry.online;
        const timeStr = entry && entry.lastSeen ? formatTimestamp(entry.lastSeen) : "æœªçŸ¥";

        // æ›´æ–°å½“å‰å¡ç‰‡çš„çŠ¶æ€æ˜¾ç¤º
        if (isOnline) {
          document.getElementById(`status_${cardIdx}`).innerText = "ğŸŸ¢ åœ¨çº¿";
          document.getElementById(`lastseen_${cardIdx}`).innerText = "";
        } else {
          document.getElementById(`status_${cardIdx}`).innerText = "ğŸ”´ ç¦»çº¿";
          document.getElementById(`lastseen_${cardIdx}`).innerText = `ä¸Šæ¬¡åœ¨çº¿ï¼š${timeStr}`;
        }
      });
    })
    .catch(() => {
      // ç½‘ç»œé”™è¯¯æ—¶ï¼Œæ‰¹é‡æ›´æ–°æ‰€æœ‰å¡ç‰‡çš„é”™è¯¯çŠ¶æ€
      cardMapping.forEach((_, cardIdx) => {
        document.getElementById(`status_${cardIdx}`).innerText = "âš ï¸ ç½‘ç»œé”™è¯¯";
        document.getElementById(`lastseen_${cardIdx}`).innerText = "";
      });
    });
}

  
async function loadAndRenderDevices() {
  const old = {};
  devices.forEach(d => {
    old[d.id] = {
    brightness:            d.brightness,
    temp:                  d.temp,
    auto:                  d.auto,
    mainColorRGB:          d.mainColorRGB,
    fabric:                d.fabric
  };
});

  const host = getHost();
  const res  = await fetch(`http://${host}:3000/devices`);
  const data = await res.json();
 
  data.sort((a, b) => {
    const aCam = a.id.toLowerCase().startsWith('camlamp');
    const bCam = b.id.toLowerCase().startsWith('camlamp');
    if (aCam !== bCam) return aCam - bCam;      
    const na = parseInt(a.id.match(/\d+/)?.[0] || '0', 10);
    const nb = parseInt(b.id.match(/\d+/)?.[0] || '0', 10);
    return na - nb;
  });

  devices = data.map(d => ({
    id:       d.id,
    type:     d.id.toLowerCase().startsWith('camlamp') ? 'camlamp' : 'lamp',
    idNum:    parseInt(d.id.match(/\d+/)?.[0] || '0', 10),
    ip:       d.ip,
    brightness: old[d.id]?.brightness  ?? d.brightness,
    temp:       old[d.id]?.temp        ?? d.temp,
    auto:       old[d.id]?.auto        ?? d.auto,
     recommendedBrightness: d.recommendedBrightness,
    recommendedTemp:       d.recommendedTemp,
    mainColorRGB:  old[d.id]?.mainColorRGB   ?? d.mainColorRGB,
    fabric:      old[d.id]?.fabric         ?? d.fabric 
    
  }));
  renderDevices(); 
  drawScene();      
}


function updateBrightness(cardIdx, value, options = {}) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];

  d.brightness = Number(value);
  updateDisplay(cardIdx);
  drawScene();

if (options.immediate) {
  send(cardIdx);
} else if (!d.auto) {
  console.log('â†’ è°ƒç”¨ debouncedSend(', cardIdx, ') for', d.id);
  debouncedSend(cardIdx);
}

}


function updateTemp(cardIdx, value, options = {}) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];

  d.temp = Number(value);
  updateDisplay(cardIdx);
  drawScene();

if (options.immediate) {
  send(cardIdx);
} else if (!d.auto) {
  console.log('â†’ è°ƒç”¨ debouncedSend(', cardIdx, ') for', d.id);
  debouncedSend(cardIdx);
}

}



function send(cardIdx) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const device = devices[realIdx];

  const payload = {
    type:                   'state',
    id:                     device.id,
    brightness:             device.brightness,
    temp:                   device.temp,
    recommendedBrightness:  device.recommendedBrightness,
    recommendedTemp:        device.recommendedTemp,
    auto:                   device.auto,
    mainColorRGB:           device.mainColorRGB
  };

  // å‘åˆ°è®¾å¤‡è‡ªèº«
  /*fetch(`http://${device.ip}/setLight`, {
    method:  'POST',
    headers: { 'Content-Type': 'application/json' },
    body:    JSON.stringify(payload)
  })
  .then(res => {
    if (!res.ok) throw new Error(res.status);
    console.log(`âœ… [è®¾å¤‡] å·²å‘ â†’ ${device.id}`);
  })
  .catch(err => console.warn(`âŒ [è®¾å¤‡] é”™è¯¯ â†’ ${device.id}`, err));*/

  // æ›´æ–°åˆ°ä¸­å¿ƒæœåŠ¡å™¨
  const host = getHost();
  fetch(`http://${host}:3000/devices/${device.id}`, {
    method:  'PUT',
    headers: { 'Content-Type': 'application/json' },
    body:    JSON.stringify({
      brightness:            device.brightness,
      temp:                  device.temp,
      auto:                  device.auto,
      recommendedBrightness: device.recommendedBrightness,
      recommendedTemp:       device.recommendedTemp,
      mainColorRGB:          device.mainColorRGB,
      fabric:                device.fabric
    })
  })
  .then(res => {
    if (!res.ok) throw new Error(res.status);
    console.log(`âœ… [æœåŠ¡å™¨] æ›´æ–°æˆåŠŸ â†’ ${device.id}`);
  })
  .catch(err => console.warn(`âŒ [æœåŠ¡å™¨] æ›´æ–°å¤±è´¥ â†’ ${device.id}`, err));

  // 3) WebSocket åŒæ­¥
  /*
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(payload));
    console.log('â†’ WS å·²å‘:', payload);
  }*/
}


function processImageFile(event, cardIdx) {
  const realIdx = cardMapping[cardIdx];
  const file = event.target.files[0];
  if (!file) return;
  const host = getHost();
  const deviceId = devices[realIdx].id;

  // å…ˆä¸Šä¼ å›¾ç‰‡åˆ° /uploadImage
  fetch(`http://${host}:3000/uploadImage?device=${deviceId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'image/jpeg' },
    body: file
  })
  .then(res => {
    if (!res.ok) throw new Error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥');
    return res.json();
  })
  .then(data => {
    console.log('âœ… å›¾ç‰‡ä¸Šä¼ å®Œæˆ:', data.filename);
/*
    // ä¸Šä¼ å®Œæˆåå†è°ƒç”¨æ£€æµ‹æ¥å£
    return fetch(`http://${host}:3000/uploadImageDetect?device=${deviceId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'image/jpeg' },
      body: file
    });
  })
  .then(res => {
    if (!res.ok) throw new Error('å›¾ç‰‡æ£€æµ‹æ¥å£è°ƒç”¨å¤±è´¥');
    return res.json();
  })
  .then(data => {
    console.log('âœ… å›¾ç‰‡æ£€æµ‹å®Œæˆ:', data);  
     */
  })
  .catch(err => {
    console.error('âŒ è¿‡ç¨‹å‡ºé”™:', err);
 
  });
}



/*async function processImageDataUrl(dataUrl, cardIdx) {
fetch(dataUrl)
    .then(res => res.blob())
    .then(blob => {
      const form = new FormData();
      form.append("image", blob, "upload.jpg");

      // 2. è·å–è®¾å¤‡ID
      const deviceId = devices[idx].id;

      // 3. å‘èµ· POST è¯·æ±‚ä¸Šä¼ å›¾ç‰‡
      fetch(`http://${host}:3000/uploadImage?device=${deviceId}`, {
        method: "POST",
        body: form
      }).then(res => res.json()).then(data => {
        console.log("âœ… ä¸Šä¼ æˆåŠŸï¼ŒæœåŠ¡å™¨å“åº”ï¼š", data);
        // å¯é€‰ï¼šå¼¹å‡ºæç¤ºæˆ–åˆ·æ–°çŠ¶æ€
      }).catch(err => {
        console.error("âŒ ä¸Šä¼ å¤±è´¥ï¼š", err);
      });
    });
  const realIdx = cardMapping[cardIdx];
  const img = new Image();
  img.onload = async () => {
    // â€”â€” A. åœ¨éšè— canvas (this.canvas) ä¸Šç»˜åˆ¶åŸå›¾
    const hidden = document.getElementById('canvas');
    hidden.width = img.width;
    hidden.height = img.height;
    const hCtx = hidden.getContext('2d');
    hCtx.drawImage(img, 0, 0);

    // â€”â€” B. BodyPix åˆ†å‰²
    const partSeg = await bodyPixNet.segmentPersonParts(img, { segmentationThreshold: 0.5 });
    const keepParts = new Set([2,3,4,5,8,9,10,11,12,13]);

    // â€”â€” C. æ„é€  mask
    const maskImg = new ImageData(img.width, img.height);
let hasPart = false;
for (let i = 0; i < partSeg.data.length; i++) {
  const off = i * 4;
  const keep = keepParts.has(partSeg.data[i]);
  maskImg.data[off+3] = keep ? 255 : 0;
  if (keep) hasPart = true;
}

// â€”â€” D. åœ¨ autoCanvas ä¸Šé¢„è§ˆè¡£æœä¸»ä½“ â€”â€” 
const autoCanvas = document.getElementById(`autoCanvas_${cardIdx}`);
autoCanvas.width  = img.width;
autoCanvas.height = img.height;
const pCtx = autoCanvas.getContext('2d');
pCtx.clearRect(0, 0, autoCanvas.width, autoCanvas.height);

if (hasPart) {
  // æœ‰æ£€æµ‹åˆ°ä¸»ä½“ï¼Œå…ˆç”»é®ç½©å†è£åˆ‡
  pCtx.putImageData(maskImg, 0, 0);
  pCtx.globalCompositeOperation = 'source-in';
  pCtx.drawImage(img, 0, 0);
  pCtx.globalCompositeOperation = 'source-over';
} else {
  // æ²¡æ£€æµ‹åˆ°ä¸»ä½“ï¼Œç›´æ¥æ˜¾ç¤ºæ•´å›¾
  pCtx.drawImage(img, 0, 0);
}

      // â€”â€” E. æå–åƒç´ ã€kMeans æ‰¾ä¸»è‰² â€”â€” 
    const imgData = hidden.getContext('2d').getImageData(0,0,hidden.width,hidden.height).data;
    const pixels = [];
    if (hasPart) {
    for (let i = 0; i < partSeg.data.length; i++) {
      if (keepParts.has(partSeg.data[i])) {
        const off = i * 4;
        pixels.push([imgData[off], imgData[off+1], imgData[off+2]]);
      }
    }}
    else {
  for (let off = 0; off < imgData.length; off += 4) {
    pixels.push([imgData[off], imgData[off+1], imgData[off+2]]);
  }
}
    const { centroids, counts } = kMeans(pixels, 3);
    const maxIdx = counts.indexOf(Math.max(...counts));
    const [r,g,b] = centroids[maxIdx];
    // â€”â€” F. è®¡ç®—æ¨èäº®åº¦å’Œè‰²æ¸© â€”â€” 
    const [h, s, v] = rgbToHsv(r, g, b);
    const recTemp = Math.round(h/360*(6500-2700)+2700);
    const recBri = Math.round((1 - v) * 60 + 40);
    
    // â€”â€” G. å­˜åˆ° devices å¹¶æ›´æ–° UI â€”â€” 
    const d = devices[realIdx];
    d.mainColorRGB      = `rgb(${r|0},${g|0},${b|0})`;
    d.recommendedTemp   = recTemp;
    d.recommendedBright = recBri;

    const shirt = shirts.find(s => s.lampIdx === realIdx);
    if (shirt) {
    shirt.color = d.mainColorRGB;
    }

    if (d.auto) applyRecommendations(cardIdx);
    updateDisplay(cardIdx);
    const box = document.getElementById(`colorBox_${cardIdx}`);
    const rgbStr = `rgb(${r},${g},${b})`;
        if (box) {
      box.style.background = d.mainColorRGB;
      box.innerText        = d.mainColorRGB;
    }
    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

    if (luminance > 186) {
      box.style.color = '#000';
    } else {
      box.style.color = '#fff';
    }
      };
      img.src = dataUrl;

    }*/

/*function kMeans(data, k = 3, maxIter = 20, tol = 1e-4) {
  if (!data.length) return { centroids: [], counts: [] };
  const centroids = [];
  centroids.push(data[Math.floor(Math.random() * data.length)]);
  for (let i = 1; i < k; i++) {
    const dists = data.map(p => {
      return Math.min(...centroids.map(c =>
        (p[0]-c[0])**2 + (p[1]-c[1])**2 + (p[2]-c[2])**2
      ));
    });
    const sum = dists.reduce((a,b) => a + b, 0);
    let r = Math.random() * sum;
    let idx = dists.findIndex(d => { r -= d; return r <= 0; });
    centroids.push(data[idx < 0 ? 0 : idx]);
  }

  let labels = new Array(data.length);
  let prevCentroids = centroids.map(c => [...c]);
  let counts = new Array(k).fill(0);

  for (let iter = 0; iter < maxIter; iter++) {
    for (let i = 0; i < data.length; i++) {
      let best = 0, minD = Infinity;
      for (let j = 0; j < k; j++) {
        const d = (data[i][0] - centroids[j][0])**2
                + (data[i][1] - centroids[j][1])**2
                + (data[i][2] - centroids[j][2])**2;
        if (d < minD) { minD = d; best = j; }
      }
      labels[i] = best;
    }

    const sums = Array.from({ length: k }, () => [0, 0, 0]);
    counts = new Array(k).fill(0);
    for (let i = 0; i < data.length; i++) {
      const l = labels[i];
      sums[l][0] += data[i][0];
      sums[l][1] += data[i][1];
      sums[l][2] += data[i][2];
      counts[l]++;
    }

    prevCentroids = centroids.map(c => [...c]);
    for (let j = 0; j < k; j++) {
      if (counts[j] > 0) {
        centroids[j][0] = sums[j][0] / counts[j];
        centroids[j][1] = sums[j][1] / counts[j];
        centroids[j][2] = sums[j][2] / counts[j];
      }
    }

    const shift = centroids.reduce((acc, c, j) => {
      return acc + (c[0]-prevCentroids[j][0])**2
                 + (c[1]-prevCentroids[j][1])**2
                 + (c[2]-prevCentroids[j][2])**2;
    }, 0);
    if (shift < tol) break;
  }
  return { centroids, counts };
}*/

function rgbToHsv(r, g, b) {
  r/=255; g/=255; b/=255;
  const mx = Math.max(r,g,b), mn = Math.min(r,g,b), d = mx-mn;
  let h = 0;
  if (d) {
    if (mx===r) h = ((g-b)/d)%6;
    else if (mx===g) h = (b-r)/d + 2;
    else h = (r-g)/d + 4;
  }
  h = Math.round(60 * h);
  if (h<0) h+=360;
  const s = mx? d/mx : 0;
  const v = mx;
  return [h, s, v];
}

function updateDisplay(cardIdx) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];

  // æ ¹æ®æ¨¡å¼å†³å®šç”¨å“ªä¸ªå€¼æ˜¾ç¤º
  const isAuto   = Boolean(d.auto);
  const displayB = isAuto ? d.recommendedBrightness : d.brightness;
  const displayT = isAuto ? d.recommendedTemp       : d.temp;

  const brightEl = document.getElementById(`currentBrightness_${cardIdx}`);
  const tempEl   = document.getElementById(`currentTemp_${cardIdx}`);
  if (brightEl) brightEl.innerText = displayB + '%';
  if (tempEl)   tempEl.innerText   = displayT + 'K';
}


function toggleAuto(cardIdx, isAuto) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];

  d.auto = isAuto;

  const bSl = document.getElementById(`brightnessSlider_${cardIdx}`);
  const tSl = document.getElementById(`tempSlider_${cardIdx}`);

  bSl.disabled = isAuto;
  tSl.disabled = isAuto;

  if (isAuto) {
    bSl.classList.add('slider-disabled');
    tSl.classList.add('slider-disabled');
  } else {
    bSl.classList.remove('slider-disabled');
    tSl.classList.remove('slider-disabled');
  }

  if (isAuto) {
    bSl.value = d.recommendedBrightness;
    tSl.value = d.recommendedTemp;
    updateDisplay(cardIdx);
    debouncedSend(cardIdx);
  } else {
    send(cardIdx);
  }

  if (!isAuto) {
    document.getElementById('autoModeCard').classList.remove('active');
  }
}



function buildLamps() {
  const sorted = [...devices].sort((a, b) => {
    const aCam = a.type === 'camlamp';
    const bCam = b.type === 'camlamp';
    if (aCam !== bCam) return aCam - bCam;
    return a.idNum - b.idNum;
  });

  const cw = sceneCanvas.width;
  const lampCount = sorted.length;

  const gap = Math.min(400, cw / (lampCount + 1)); 
  const totalWidth = (lampCount - 1) * gap;
  const startX = (cw - totalWidth) / 2;

  const lampData = sorted.map((d, idx) => ({
    x: startX + idx * gap,
    recommendedBrightness: d.recommendedBrightness,
    recommendedTemp: d.recommendedTemp,
    idx: devices.indexOf(d),
    originalIndex: devices.indexOf(d)
  }));

  shirts = lampData.map(l => {
  const prev = shirts.find(s => s.lampIdx === l.originalIndex);
  const sleeveW = 20, torsoW = 60;
  return {
    x: l.x - (sleeveW + torsoW/2), 
    y: 320,
    lampIdx: l.originalIndex,
    color: prev?.color || pendingColors[l.originalIndex] || "#888"
  };
});


  return lampData;
}

const ctx3 = sceneCanvas.getContext("2d");

function tempToRGB(recommendedTemp) {
  recommendedTemp = Math.max(1000, Math.min(40000, recommendedTemp)) / 100; 

  let r, g, b;

  if (recommendedTemp <= 66) {
    r = 255;
    g = recommendedTemp <= 19
      ? 0
      : 99.4708025861 * Math.log(recommendedTemp) - 161.1195681661;
    b = recommendedTemp <= 19
      ? 0
      : (138.5177312231 * Math.log(recommendedTemp - 10) - 305.0447927307);
  } else {
    r = 329.698727446 * Math.pow(recommendedTemp - 60, -0.1332047592);
    g = 288.1221695283 * Math.pow(recommendedTemp - 60, -0.0755148492);
    b = 255;
  }

  r = Math.min(255, Math.max(0, r));
  g = Math.min(255, Math.max(0, g));
  b = Math.min(255, Math.max(0, b));

  return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},`;
}

function drawRoom() {
  const c = ctx3, W = sceneCanvas.width;
  c.fillStyle = "#3a3a3a";
}

function drawVolumetricLight(x, recommendedBrightness, recommendedTemp) {
  const baseY=70, bottomY=420;
  for (let i=0;i<50;i++){
    const alpha = Math.max(0, recommendedBrightness / 100 * 0.25 - i * 0.005);
    const expansion = 50 + i*2;
    const color = tempToRGB(recommendedTemp) + alpha.toFixed(2) + ")";
    const grad = ctx3.createRadialGradient(x, baseY+30, 5, x, (baseY+bottomY)/2,200);
    grad.addColorStop(0, color); grad.addColorStop(1, "rgba(255,255,255,0)");
    ctx3.fillStyle = grad;
    ctx3.beginPath();
    ctx3.moveTo(x, baseY);
    ctx3.lineTo(x-expansion, bottomY);
    ctx3.lineTo(x+expansion, bottomY);
    ctx3.closePath(); ctx3.fill();
  }
}

function drawLamps() {
  const lamps = buildLamps();
  lamps.forEach(l => {
    // å…‰æŸ±
    drawVolumetricLight(l.x, l.recommendedBrightness, l.recommendedTemp);
    // 2. åŠæ†
    /*
    ctx3.beginPath();
    ctx3.strokeStyle = "#444";
    ctx3.lineWidth = 2;
    ctx3.moveTo(l.x, 20);  // æ›´é ä¸Š
    ctx3.lineTo(l.x, 55);  // æ›´é•¿ï¼Œå»¶ä¼¸åˆ°åº•éƒ¨ç¯ç½©é¡¶
    ctx3.stroke();

    // 3. ç¯ç½©ï¼ˆæ›´å¤§ã€æ›´åšï¼‰
    ctx3.beginPath();
    ctx3.fillStyle = "#6ea2ba";  // è«å…°è¿ªè“
    ctx3.ellipse(l.x, 70, 28, 20, 0, 0, Math.PI, true);  // ç›´å¾„æ›´å¤§ã€åšåº¦æ›´æ·±
    ctx3.fill();

    // 4. ç¯ç½©ä¸‹ç¼˜è¾¹æ¡†ï¼ˆå¢å¼ºç«‹ä½“æ„Ÿï¼‰
    ctx3.beginPath();
    ctx3.fillStyle = "#4b6d82";  // æ·±è‰²è¾¹ç¼˜
    ctx3.ellipse(l.x, 70, 28, 5, 0, 0, 2 * Math.PI);
    ctx3.fill();

    // 5. å†…éƒ¨ç¯å…‰å£ï¼ˆç™½è‰²å‘å…‰åŒºï¼‰
    ctx3.beginPath();
    ctx3.fillStyle = "#fff";
    ctx3.ellipse(l.x, 70, 24, 4, 0, 0, 2 * Math.PI);
    ctx3.fill();*/
    

    ctx3.beginPath();
    ctx3.strokeStyle = "#444";
    ctx3.lineWidth = 2;
    ctx3.moveTo(l.x, 20);
    ctx3.lineTo(l.x, 55);
    ctx3.stroke();

    // 3. ç¯ç½©ï¼ˆæ›´æ·±æ›´çª„çš„åŠçƒä½“ï¼‰
    ctx3.beginPath();
    ctx3.fillStyle = "#6ea2ba";  // è«å…°è¿ªè“
    ctx3.ellipse(l.x, 70, 22, 22, 0, 0, Math.PI, true);  // æ›´åœ†æ›´æ·±
    ctx3.fill();

    // 4. ç¯ç½©ä¸‹æ²¿æè¾¹ï¼ˆåšè¾¹ç¼˜ï¼‰
    ctx3.beginPath();
    ctx3.fillStyle = "#3c5566";
    ctx3.ellipse(l.x, 70, 22, 4, 0, 0, 2 * Math.PI);
    ctx3.fill();

    // 5. ç¯å…‰å£ï¼ˆå˜å°ã€æ›´é›†ä¸­ï¼‰
    ctx3.beginPath();
    ctx3.fillStyle = "#fff";
    ctx3.ellipse(l.x, 70, 14, 2.5, 0, 0, 2 * Math.PI);
    ctx3.fill();
  });
}

function drawShirt(s) {
  const ctx = ctx3;
  const x = s.x;
  const y = s.y;
  const torsoW = 60, torsoH = 80;
  const sleeveW = 20, sleeveH = 40, angle = 15;
  const rgb = s.color;
  const colorStr = typeof rgb === 'string' ? rgb : `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;

  // å½±å­
  ctx.beginPath();
  ctx.ellipse(x + torsoW/2 + sleeveW, y + torsoH + sleeveH + 10, 40, 12, 0, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fill();


  ctx.fillStyle = colorStr;

  // å·¦è¢–
  ctx.beginPath();
  ctx.moveTo(x, y + angle);
  ctx.lineTo(x + sleeveW, y);
  ctx.lineTo(x + sleeveW, y + sleeveH);
  ctx.lineTo(x, y + sleeveH + angle);
  ctx.closePath();
  ctx.fill();

  // èº«ä½“
  ctx.fillRect(x + sleeveW, y, torsoW, torsoH);

  // å³è¢–
  const rx = x + sleeveW + torsoW;
  ctx.beginPath();
  ctx.moveTo(rx, y);
  ctx.lineTo(rx + sleeveW, y + angle);
  ctx.lineTo(rx + sleeveW, y + sleeveH + angle);
  ctx.lineTo(rx, y + sleeveH);
  ctx.closePath();
  ctx.fill();

  // é¢†å£
  const cx = x + sleeveW + torsoW / 2;
  ctx.beginPath();
  ctx.fillStyle = "#ccc";
  ctx.arc(cx, y, 15, 0, Math.PI, false);
  ctx.fill();

  // æè¾¹ 
  ctx.beginPath();

  ctx.moveTo(x, y + sleeveH + angle);                         // å·¦è¢–ä¸‹
  ctx.lineTo(x + sleeveW, y + sleeveH);                      // è¢–æ ¹
  ctx.lineTo(x + sleeveW, y + torsoH);                       // èº«ä½“å·¦ä¸‹
  ctx.lineTo(x + sleeveW + torsoW, y + torsoH);              // èº«ä½“å³ä¸‹
  ctx.lineTo(x + sleeveW + torsoW, y + sleeveH);             // è¢–æ ¹å³
  ctx.lineTo(x + sleeveW + torsoW + sleeveW, y + sleeveH + angle); // å³è¢–ä¸‹
  ctx.lineTo(x + sleeveW + torsoW + sleeveW, y + angle);     // å³è¢–ä¸Š
  ctx.lineTo(x + sleeveW + torsoW, y);                       // èº«ä½“å³ä¸Š
  ctx.lineTo(x + sleeveW, y);                                // èº«ä½“å·¦ä¸Š
  ctx.lineTo(x, y + angle);                                  // å·¦è¢–ä¸Š
  ctx.closePath();

  ctx.strokeStyle = "black";
  ctx.lineWidth = 0.8;
  ctx.stroke();

}


function drawScene() {
  ctx3.clearRect(0, 0, sceneCanvas.width, sceneCanvas.height);
  drawRoom();
  const lamps = buildLamps();   
  lamps.forEach(l => drawVolumetricLight(l.x, l.recommendedBrightness, l.recommendedTemp));
  drawLamps();
  shirts.forEach(drawShirt);
}


document.addEventListener('DOMContentLoaded', () => {
  // â€”â€” å…¨å±€ä¸Šä¼ æ§ä»¶ & å½“å‰é€‰ä¸­å¡ç‰‡ç´¢å¼• â€”â€” 
  uploader = document.getElementById('uploader')
  
 if (uploader) {
    uploader.addEventListener("change", e => {
      const file = uploader.files[0];
      if (!file || selectedCardIdx === null) return;
      processImageFile({ target: { files: [file] } }, selectedCardIdx);
      selectedCardIdx = null;
      uploader.value = '';
    });
  }
sceneCanvas.addEventListener("click", e => {
  // æŠŠå®¢æˆ·ç«¯åæ ‡è½¬æˆç”»å¸ƒå†…éƒ¨åæ ‡
  const rect = sceneCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (sceneCanvas.width  / rect.width);
  const y = (e.clientY - rect.top ) * (sceneCanvas.height / rect.height);

  const lamps = buildLamps();
  for (let l of lamps) {
    const s = shirts.find(s=>s.lampIdx===l.originalIndex);
    if (!s) continue;
    if (x>=s.x && x<=s.x+60 && y>=s.y && y<=s.y+80) {
      selectedCardIdx = s.lampIdx;
      uploader.click();
      return;
    }
  }
  lamps.forEach(l => {
    if (Math.abs(x - l.x) < 20 && y >= 50 && y <= 100) {
      const realIdx = l.originalIndex;
      const cardIdx = cardMapping.findIndex(idx => idx===realIdx);
      if (cardIdx>=0) openControlModal(cardIdx);
    }
  });
});
  function safeText(id, txt) {
    const el = document.getElementById(id);
    if (el) el.textContent = txt;
  }
  function safeHTML(id, html) {
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  }

  // â€”â€” äººæµé¢„æµ‹ & èˆ’é€‚åº¦è®¡ç®— â€”â€”  
function predictPeople(area, tempVal) {
  // é¢ç§¯æƒé‡ï¼Œ0.7æ¬¡æ–¹æ”¾å¤§
  const areaWeight = Math.pow(area, 0.7) * 4;

  // æ—¶é—´æƒé‡ï¼Œåˆ†æ®µæ›´ç»†ï¼Œæ¨¡æ‹Ÿæ›´ä¸°å¯Œçš„å³°è°·
  const now = new Date();
  const hour = now.getHours();
  const timeWeight = (() => {
    if (hour >= 6 && hour < 9) return 0.8;    // æ—©é«˜å³°å‰æ®µ
    if (hour >= 9 && hour < 11) return 1.1;   // ä¸Šåˆæ´»è·ƒæœŸ
    if (hour >= 11 && hour < 12) return 1.4;  // åˆé¤å‰å‡†å¤‡æœŸ
    if (hour >= 12 && hour < 14) return 1.6;  // åˆé¤é«˜å³°
    if (hour >= 14 && hour < 17) return 0.9;  // åˆåå¹³ç¨³
    if (hour >= 17 && hour < 19) return 2.0;  // æ™šé¥­é«˜å³°
    if (hour >= 19 && hour < 20) return 1.7;  // æ™šé¥­ååŠé«˜å³°
    if (hour >= 20 && hour < 21) return 1.0;  // æ™šé—´å¹³ç¨³
    if (hour >= 21 && hour < 23) return 0.6;  // å¤œé—´ä½è°·
    return 0.4;                               // 23-6ç‚¹ï¼Œå¤œæ·±äººé™
  })();

  // æ°”æ¸©æƒé‡ï¼Œç»†åˆ†æ›´å¤šæ¡£æ¬¡ï¼Œæ›´è´´åˆèˆ’é€‚åº¦å½±å“
const tempWeight = (() => {
  if (tempVal < 0) return 0.5;                  // æå†·
  if (tempVal >= 0 && tempVal < 10) return 0.6; // å¾ˆå†·ï¼ˆå¯è‡ªå·±è°ƒæ•´ï¼‰
  if (tempVal >= 10 && tempVal < 13) return 0.7; // å†·
  if (tempVal >= 13 && tempVal < 15) return 0.8; // è¾ƒå†·
  if (tempVal >= 15 && tempVal < 18) return 0.85; // åå†·
  if (tempVal >= 18 && tempVal < 20) return 1.0;  // è¾ƒé€‚å®œ
  if (tempVal >= 20 && tempVal < 22) return 1.2;  // ç¨å¾®å‡‰çˆ½
  if (tempVal >= 22 && tempVal <= 26) return 1.4; // æœ€èˆ’é€‚åŒº
  if (tempVal > 26 && tempVal <= 28) return 0.9;  // èˆ’é€‚åçƒ­
  if (tempVal > 28 && tempVal <= 30) return 0.75; // è¾ƒçƒ­
  if (tempVal > 30 && tempVal <= 40) return 0.6;  // å¾ˆçƒ­
  if (tempVal > 40) return 0.5;                   // æçƒ­

  return 0.75; // é»˜è®¤å€¼ï¼ˆå¯è¦†ç›–å¼‚å¸¸æƒ…å†µï¼‰
})();

const weekdayWeight = (() => {
  const day = now.getDay(); // 0 æ˜¯å‘¨æ—¥
  if (day === 0 || day === 6) return 1.3; // å‘¨æœ«äººæµå¤š
  return 1.0; // å·¥ä½œæ—¥
})();

const weatherWeight = (() => {
  switch (cachedWeatherType) {
    case 'Rain': return 0.6;      // é›¨å¤©äººå°‘
    case 'Snow': return 0.5;      // é›ªå¤©æ›´å°‘
    case 'Clouds': return 0.9;    // é˜´å¤©ç•¥å°‘
    case 'Clear': return 1.0;     // æ™´å¤©æ­£å¸¸
    case 'Thunderstorm': return 0.4; // é›·é›¨å¾ˆå°‘äººå‡ºé—¨
    case 'Drizzle': return 0.7;
    default: return 0.8;          // å…¶ä»–é»˜è®¤ç•¥å°‘
  }
})();
  // å™ªå£°è°ƒæ•´ï¼ŒÂ±1.5ï¼Œæ¨¡æ‹Ÿéšæœºæ³¢åŠ¨
  const noise = (Math.random() - 0.5) * 3;

  // åŸºç¡€äººæ•°ï¼Œé¿å…å¤ªä½
  const baseCount = 0;

  // ç»¼åˆé¢„æµ‹
  const predictionRaw = baseCount + areaWeight * timeWeight * tempWeight * weekdayWeight * weatherWeight;//+ noise;
  const prediction = predictionRaw * 0.7;
  return Math.max(0, Math.round(prediction));
}


  function comfortScore(temp, people) {
    const tC = 1 - Math.min(Math.abs(temp-22)/15,1);
    let pC;
    if (people <= 20) pC = people/20;
    else if (people >= 60) pC = Math.max(0,(100-people)/(100-60));
    else pC = 1;
    return Math.max(0,(tC + pC)/2);
  }

  // â€”â€” è·å– canvas â€”â€”  
  const stratCanvas = document.getElementById('strategyChart');
  const tempCanvas  = document.getElementById('tempChart');
  const distCanvas  = document.getElementById('distributionChart');
  if (!stratCanvas || !tempCanvas || !distCanvas) return;

  const stratCtx = stratCanvas.getContext('2d');
  const tempCtx  = tempCanvas.getContext('2d');
  const distCtx  = distCanvas.getContext('2d');

  // â€”â€” åˆå§‹åŒ– Chart.js â€”â€”  
const tempChart = new Chart(tempCtx, {
  type: 'line',
  data: {
    labels: [],
    datasets: [
      { label: 'æ¸©åº¦ (Â°C)', data: [], borderColor: 'rgba(75,192,192,1)', fill: false, yAxisID: 'y' },
      { label: 'äººæµé‡',     data: [], borderColor: 'rgba(255,99,132,1)', fill: false, yAxisID: 'y1' }
    ]
  },
  options: {
    responsive: true,
    animation: false,
    scales: {
      x: { title: { display: true, text: 'æ—¶é—´' } },
      y: { position: 'left',  title: { display: true, text: 'æ¸©åº¦ (Â°C)' }, min: 0,  max: 40 },
      y1:{ position: 'right', title: { display: true, text: 'äººæµé‡' },     min: 0,  max: 100, grid:{drawOnChartArea:false} }
    }
  }
});

const distributionChart = new Chart(distCtx, {
  type: 'bar',
  data: {
    labels: ['ç¯1','ç¯2','ç¯3','ç¯4'],
    datasets: [
      { label: 'æ¯ç›ç¯äº®åº¦ (æµæ˜)', data: [400,400,400,400], backgroundColor:'rgba(54,162,235,0.6)' }
    ]
  },
  options: {
    responsive: true,
    animation: false,
    scales: { y: { min: 300, max: 1000 } }
  }
});

const strategyChart = new Chart(stratCtx, {
  type: 'line',
  data: {
    labels: [],
    datasets: [
      { label: 'æ’å®šäº®åº¦ (900)', data: [], borderColor:'gray',  borderWidth:2, fill:false },
      { label: 'è‡ªé€‚åº”äº®åº¦',     data: [], borderColor:'blue',  borderWidth:2, fill:false },
      { label: 'æ··åˆç­–ç•¥',       data: [], borderColor:'green', borderWidth:2, fill:false }
    ]
  },
  options: {
    responsive: true,
    animation: false,
    scales: {
      x: { title: { display: true, text: 'æ—¶é—´' } },
      y: { title: { display: true, text: 'äº®åº¦ (æµæ˜)' }, min: 300, max: 1000 }
    }
  }
});


  // â€”â€” äº¤äº’æ§ä»¶ â€”â€”  
  let storeArea = 80;
  const storeSelect = document.getElementById('storeSelect');
  if (storeSelect) storeSelect.addEventListener('change', e => {
    const v = parseInt(e.target.value.split(',')[1]);
    if (!isNaN(v)) storeArea = v;
  });

  const toggleBtn = document.getElementById('toggleMode');
  if (toggleBtn) {
    let day = true;
    toggleBtn.addEventListener('click', () => {
      day = !day;
      document.body.style.background = day ? '#def' : '#222';
      document.body.style.color      = day ? '#333' : '#eee';
    });
  }

let updateCounter = 10;
  // â€”â€” æ ¸å¿ƒæ›´æ–°å‡½æ•° â€”â€”  
function updateData() {
  const now  = new Date();
  const time = now.toLocaleTimeString();
  updateCounter++;

  // 1. ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
  const tempVal = parseFloat(cachedTempVal.toFixed(1));
  const ppl      = predictPeople(storeArea);
  const adaptive = Math.round((400 + ppl * 5) * 1.15);
  const mixed    = Math.round(0.3 * 900 + 0.7 * adaptive);

  // â€”â€” æ›´æ–° æ¸©åº¦&äººæµ æŠ˜çº¿å›¾ â€”â€”  
  if (tempChart.data.labels.length >= 12) {
    tempChart.data.labels.shift();
    tempChart.data.datasets[0].data.shift();
    tempChart.data.datasets[1].data.shift();
  }
  tempChart.data.labels.push(time);
  tempChart.data.datasets[0].data.push(tempVal);
  tempChart.data.datasets[1].data.push(ppl);
  tempChart.update();

  // â€”â€” æ›´æ–° æ¯ç›ç¯äº®åº¦ æŸ±çŠ¶å›¾ â€”â€”  
  distributionChart.data.datasets[0].data = [adaptive, adaptive, adaptive, adaptive];
  distributionChart.update();

  // â€”â€” æ›´æ–° ç­–ç•¥å¯¹æ¯” æŠ˜çº¿å›¾ â€”â€”  
  if (strategyChart.data.labels.length >= 20) {
    strategyChart.data.labels.shift();
    strategyChart.data.datasets.forEach(ds => ds.data.shift());
  }
  strategyChart.data.labels.push(time);
  strategyChart.data.datasets[0].data.push(900);
  strategyChart.data.datasets[1].data.push(adaptive);
  strategyChart.data.datasets[2].data.push(mixed);
  strategyChart.update();

  // â€”â€” æ–‡æœ¬åŒºæ›´æ–° â€”â€”  
  safeText('dateInfo',     now.toLocaleDateString());
  safeText('weekInfo',    'æ˜ŸæœŸ' + ['æ—¥','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­'][now.getDay()]);
  safeText('holidayInfo', 'æ˜¯å¦èŠ‚å‡æ—¥: å¦');
  safeText('workdayInfo', 'æ˜¯å¦å·¥ä½œæ—¥: æ˜¯');
  safeText('curtime', now.toLocaleTimeString());

  safeHTML('inputs', `
    æ¸©åº¦: ${tempVal} Â°C<br>
    äººæµé‡: ${ppl} äºº<br>
    é¢ç§¯: ${storeArea}ã¡
  `);

  safeHTML('currentBriDisplay', `
    äº®åº¦å…¬å¼: (400 + äººæµé‡Ã—5) Ã— å¤©æ°”å› å­(1.15)<br>
    å½“å‰äº®åº¦: ${adaptive} æµæ˜/ç›
  `);

  const comfort  = comfortScore(tempVal, ppl);
  const saveRate = Math.max(0, (1 - mixed/900) * 100 * comfort).toFixed(1);
  safeText('SavingResult', `èŠ‚èƒ½ç‡: ${saveRate}% ï¼ˆèˆ’é€‚åº¦: ${(comfort*100).toFixed(0)}%ï¼‰`);
}


const tabs     = document.querySelectorAll('.sidebar li');
const sections = {
  main:     document.getElementById('mainSection'),
  flow:     document.getElementById('flowSection'),
  settings: document.getElementById('settingsSection'),
};

tabs.forEach(li => {
  li.addEventListener('click', () => {
    tabs.forEach(x => x.classList.remove('active'));
    li.classList.add('active');

    Object.entries(sections).forEach(([key, el]) => {
      if (el) el.style.display = (key === li.dataset.tab) ? 'block' : 'none';
    });
    if (li.dataset.tab === 'flow') {
      [strategyChart, tempChart, distributionChart].forEach(chart => {
        chart.update();
      });
    }
  });
});
  updateData();
  setInterval(updateData, 1000);

  interact('.draggable').draggable({/*â€¦*/}).resizable({/*â€¦*/});
});

// é¡µé¢åŠ è½½æ—¶ç”Ÿæˆè®¾å¤‡åˆ—è¡¨æ•°ç»„

const selectEl = document.getElementById('deviceSelect');
for (let i = 1; i < selectEl.options.length; i++) {
  const id = selectEl.options[i].value;
  devices.push({ id, socket: null });  // socket å¯ç•™ç©ºæˆ–åç»­èµ‹å€¼
}
console.log("åˆå§‹åŒ–è®¾å¤‡åˆ—è¡¨:", devices);

// å‘é€æœºæ¢°è‡‚æ§åˆ¶æŒ‡ä»¤
function sendArmCommand(direction) {
  const selectedId = selectEl.value;

  if (!selectedId) {
    console.warn("âš ï¸ æœªé€‰æ‹©è®¾å¤‡");
    return;
  }

  const selectedDevice = devices.find(d => d.id === selectedId);

  if (!selectedDevice) {
    console.warn(`âš ï¸ æœªæ‰¾åˆ°è®¾å¤‡: ${selectedId}`);
    return;
  }

  // å‘é€ç»™æœåŠ¡å™¨çš„ HTTP è¯·æ±‚
  fetch(`http://${host}:3000/devices/${selectedDevice.id}/arm`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ direction })
  })
  .then(res => res.json())
  .then(data => console.log(`[${selectedDevice.id}] æœåŠ¡å™¨è¿”å›:`, data))
  .catch(err => console.error(`[${selectedDevice.id}] å‘é€å¤±è´¥:`, err));

  console.log(`ğŸ“¤ [${selectedDevice.id}] å‘é€æœºæ¢°è‡‚æ§åˆ¶ï¼š`, direction);
}



</script>
</body>

</html>
