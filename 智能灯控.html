<!DOCTYPE html>
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="width=device-width, initial-scale=1" name="viewport">

<title>æ™ºèƒ½ç¯æ§</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.6/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/countup.js@2.0.7/dist/countup.umd.js"></script>

<style>
     :root {
      --primary: #409EFF;
      --primary-hover: #66B1FF;
      --bg: #F0F2F5;
      --card-bg: #FFFFFF;
      --text-color: #303133;
      --sub-text: #606266;
      --border-radius: 12px;
      --transition: 0.3s ease;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Helvetica Neue", sans-serif;
      background: var(--bg);
      color: var(--text-color);
      padding: 20px;
    }
    
    /* æ§åˆ¶åŒº */
    #controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      background: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      margin-bottom: 20px;
    }
    #controls button {
      background: var(--primary);
      color: #fff;
      border: none;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: background var(--transition), transform 0.2s;
    }
    #controls button:hover {
      background: var(--primary-hover);
      transform: translateY(-1px);
    }
    #controls label {
      font-size: 14px;
      color: var(--sub-text);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #controls input[type="text"] {
      width: 140px;
      padding: 6px 10px;
      font-size: 14px;
      border: 1px solid #dcdfe6;
      border-radius: 4px;
      transition: border-color 0.3s;
    }
    #controls input[type="text"]:focus {
      border-color: var(--primary);
      outline: none;
    }
    #scanStatus {
      margin-left: auto;
      font-size: 13px;
      color: var(--sub-text);
    }

    /* è®¾å¤‡å¡ç‰‡ç½‘æ ¼ */
    #deviceContainer {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
    }
    .lamp-card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .lamp-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    }
    .lamp-card h3 {
      font-size: 18px;
      margin-bottom: 8px;
    }
    .lamp-card label {
      font-size: 14px;
      color: var(--sub-text);
      margin-top: 12px;
      display: block;
    }
    .lamp-card input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      margin-top: 6px;
    }
    .lamp-card input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      transition: background var(--transition), transform 0.2s;
    }
    .lamp-card input[type="range"]::-webkit-slider-thumb:hover {
      background: var(--primary-hover);
      transform: scale(1.2);
    }
    .color-box {
      display: inline-block;
      margin-top: 10px;
      width: 180px; height: 40px;
      line-height: 40px;
      text-align: center;
      border-radius: var(--border-radius);
      border: 1px solid #ccc;
      box-shadow: inset 0 0 4px rgba(0,0,0,0.08);
      background: #888; color: #fff;
      margin-left: 10px;
    }
    .upload-btn-wrapper {
      display: inline-block;
      padding: 8px 12px;
      background: var(--primary);
      color: #fff;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 13px;
      margin-top: 6px;
      transition: background var(--transition);
      width: auto;      
      max-width: 80px; 
    }
    .upload-btn-wrapper:hover {
      background: var(--primary-hover);
    }
    .upload-btn-wrapper input {
      display: none;
    }
    .btn-delete {
      display: inline-block;
      margin-top: 10px;
      padding: 8px 12px;
      background: #F56C6C;
      color: #fff;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 13px;
      margin-top: 6px;
      transition: background var(--transition);
      width: auto;     
      max-width: 80px; 
    }
    .btn-delete:hover {
      background: #F78989;
    }

    canvas#sceneCanvas { background: #000; width: 100%;
  height: auto;
  max-width: 900px;     
  border: 1px solid #333;
  display: block;
  margin: 20px auto; }
    #panel {
      position: absolute; top: 80px; left: 50%;
      transform: translateX(-50%);
      background: #222; padding: 20px; border: 1px solid #555;
      display: none; z-index: 10;
    }
    #panel input[type="range"] { width: 200px; }
    #panel label { display: inline-block; width: 60px; text-align: right; margin-right: 10px; }
    #panel button { margin-top: 10px; }
    
    .env-wrapper {
  display: flex;
  justify-content: space-between;
  gap: 24px;
  flex-wrap: wrap;
  margin-bottom: 20px;
}

.env-left,
.env-right {
  flex: 1 1 45%;
  min-width: 300px;
}

#selectorBox select {
  background-image: url("data:image/svg+xml;utf8,<svg fill='gray' height='12' viewBox='0 0 24 24' width='12' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
  background-repeat: no-repeat;
  background-position: right 10px center;
  background-size: 12px 12px;
  padding-right: 24px; 
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

#selectorBox select,
#selectorBox button {
  width: auto;
  max-width: 140px;
  min-width: 100px;
  flex: none;
  padding: 6px 14px;
  font-size: 14px;
  height: 38px;
  white-space: nowrap;
  border-radius: 999px; 
  border: 1px solid #ccc;
  background-color: #f9f9f9;
  appearance: none; 
}

#selectorBox button {
  background-color: #409EFF;
  color: white;
  border: none;
}
.env-layout {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 24px;
}
.env-card {
  flex: 1 1 48%;
  min-width: 300px;
  background: #fff;
  padding: 16px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

</style></head>
<body><div class="env-layout card-section"><div class="env-card"><h4>å®æ—¶ç¯å¢ƒå‚æ•°</h4><div id="inputs">
                æ¸©åº¦: 20.3 Â°C<br>
                å½“å‰æ—¶é—´: 01:39:21<br>
                å®æ—¶äººæµé‡: 35 äºº<br>
                åº—é“ºé¢ç§¯: 60ã¡
            </div><div class="calc-section" id="resultDisplay"></div></div><div class="env-card"><div id="selectorBox">
<select id="citySelect">
<option value="28.1894,112.9861">é•¿æ²™</option>
<option value="31.2304,121.4737">ä¸Šæµ·</option>
<option value="39.9042,116.4074">åŒ—äº¬</option>
<option value="23.1291,113.2644">å¹¿å·</option>
</select>
<select id="storeSelect">
<option value="é«˜ç«¯,80">é«˜ç«¯åº—ï¼ˆ80ã¡ï¼‰</option>
<option value="ä¸­ç«¯,60">ä¸­ç«¯åº—ï¼ˆ60ã¡ï¼‰</option>
<option value="ä½ç«¯,40">ä½ç«¯åº—ï¼ˆ40ã¡ï¼‰</option>
</select>
<button id="toggleMode">åˆ‡æ¢æ—¥å¤œæ¨¡å¼</button>
</div><div id="metaInfo">
<div id="dateInfo">æ—¥æœŸ: 2025/6/13</div>
<div id="weekInfo">æ˜ŸæœŸ: äº”</div>
<div id="holidayInfo">æ˜¯å¦èŠ‚å‡æ—¥: å¦</div>
<div id="workdayInfo">æ˜¯å¦å·¥ä½œæ—¥: æ˜¯</div>
</div></div></div>
<h1>æ™ºèƒ½ç¯æ§</h1>
<div id="controls">
<button onclick="startDeviceScan()">æ‰«æè®¾å¤‡</button>
<button onclick="showAddDeviceModal()">æ‰‹åŠ¨æ·»åŠ è®¾å¤‡</button>
<label>
      WebSocket æœåŠ¡å™¨åœ°å€ï¼š
      <input id="wsServerInput" placeholder="192.168.110.70" type="text">
</label>
<div id="scanStatus"></div>
</div>
<div id="addDeviceModal" style="
  display:none; position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.4); z-index:9999; justify-content:center; align-items:center;
  font-family: 'Helvetica Neue', sans-serif;">
<div style="
    background:#fff; padding:30px 25px; border-radius:18px; width:320px;
    box-shadow:0 8px 30px rgba(0,0,0,0.2); text-align:center; animation:fadeIn 0.3s ease;">
<h3 style="margin-top:0; font-size:20px; color:#333;">æ‰‹åŠ¨æ·»åŠ è®¾å¤‡</h3>
<label style="display:block; text-align:left; margin-bottom:4px;">è®¾å¤‡ IDï¼š</label>
<input id="modalId" placeholder="å¦‚ lamp2" style="
      width:100%; padding:10px; border-radius:8px; border:1px solid #ccc; margin-bottom:15px;
      font-size:14px; box-sizing:border-box;" type="text">
<label style="display:block; text-align:left; margin-bottom:4px;">è®¾å¤‡ IPï¼š</label>
<input id="modalIp" placeholder="å¦‚ 192.168.1.105" style="
      width:100%; padding:10px; border-radius:8px; border:1px solid #ccc; margin-bottom:20px;
      font-size:14px; box-sizing:border-box;" type="text">
<button onclick="confirmAddDevice()" style="
      background:#4CAF50; color:#fff; padding:10px 20px; border:none;
      border-radius:10px; cursor:pointer; font-size:14px; margin-right:10px;
      transition:background 0.3s;">ç¡®è®¤æ·»åŠ </button>
<button onclick="hideAddDeviceModal()" style="
      background:#ccc; color:#333; padding:10px 20px; border:none;
      border-radius:10px; cursor:pointer; font-size:14px;
      transition:background 0.3s;">å–æ¶ˆ</button>

</div>
</div>
<canvas height="500" id="sceneCanvas" width="900"></canvas>
<input accept="image/*" id="imageUploader" style="display:none" type="file">
<div class="env-wrapper">

<div class="env-left">

</div>
<div class="env-right">



</div>
<div id="strategyWrapper">
<div id="strategyChartContainer">
<h4 style="text-align:center">äº®åº¦ç­–ç•¥å®æ—¶å¯¹æ¯”å›¾</h4>
<canvas id="strategyChart" width="686" height="343" style="display: block; box-sizing: border-box; height: 228px; width: 650px;"></canvas>
</div>
<div id="energyInfo">
<strong>èŠ‚èƒ½ç‡è®¡ç®—</strong><br><br>
            å…¬å¼ï¼š<br>
            èŠ‚èƒ½ç‡ â‰ˆ (5 â€“ æ··åˆç­–ç•¥äº®åº¦ Ã· æ’å®šäº®åº¦) Ã— 100% Ã— èˆ’é€‚åº¦ç³»æ•°<br>
            å¯¹æ¯”æ¯”ä¾‹ 3:7<br><br>
<span id="savingResult">èŠ‚èƒ½ç‡: 7.8% (èˆ’é€‚åº¦: 94%)</span>
</div>
</div><div id="main">
<div class="draggable" id="tempChartContainer">
<canvas id="tempChart" width="600" height="200" style="display: block; box-sizing: border-box; height: 100px; width:650px;"></canvas>
</div>
<div class="draggable" id="distributionChartContainer">
<canvas id="distributionChart" width="600" height="200" style="display: block; box-sizing: border-box; height: 100px; width: 650px;"></canvas>
</div>
<div class="draggable" id="calculationContainer">
<div id="calculation">
<div class="calc-section" id="inputDisplay">
<h4>è®¡ç®—äº®åº¦ç»“æœ</h4>
<div id="results">
                äº®åº¦å…¬å¼: (400 + äººæµé‡Ã—5) Ã— å¤©æ°”å› å­(1.15)<br>
                å½“å‰äº®åº¦: 661 æµæ˜/ç›
            </div>
</div>
</div>
</div></div></div>
</div>
</div><h2>å·²ç»‘å®šè®¾å¤‡</h2>
</div>
</div>
  <div id="deviceContainer"></div>
<div id="controlModal" style="
  display: none;
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.5);
  justify-content: center; align-items: center;
  z-index: 10000;
">
<div id="controlModalContent" style="
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    max-width: 400px;
    width: 90%;
    position: relative;
  ">
<button onclick="closeControlModal()" style="
      position: absolute; top: 10px; right: 10px;
      border: none; background: transparent; font-size: 20px;
      cursor: pointer;
    ">Ã—</button>
<!-- è¿™é‡Œä¼šåŠ¨æ€æ’å…¥å¡ç‰‡ HTML -->
</div>
</div>
<h3>è¡£ç‰©ä¸»ä½“é¢„è§ˆï¼š</h3>
<canvas height="300" id="previewCanvas" width="500"></canvas>
<canvas id="canvas" style="display:none;"></canvas>
<!-- è‡ªå®šä¹‰ç¡®è®¤æç¤ºæ¡† -->
<div id="customPrompt" style="
  display:none; position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.4); z-index:9999; justify-content:center; align-items:center;
  font-family: 'Helvetica Neue', sans-serif;">
<!-- å¼¹å‡ºæ¡†ä¸»ä½“ -->
<div id="customPromptBox" style="
    background:#fff; padding:20px 25px; border-radius:16px; width:320px;
    box-shadow:0 8px 30px rgba(0,0,0,0.2); text-align:center;">
<div id="customPromptText" style="font-size:16px; color:#333; margin-bottom:20px;">
      æç¤ºå†…å®¹
    </div>
<button onclick="customPromptResolve(true)" style="
    background:#4CAF50; color:#fff; padding:8px 18px; border:none;
    border-radius:10px; cursor:pointer; font-size:14px; margin-right:10px;">ç¡®å®š</button>
<button onclick="customPromptResolve(false)" style="
    background:#ccc; color:#333; padding:8px 18px; border:none;
    border-radius:10px; cursor:pointer; font-size:14px;">å–æ¶ˆ</button>
</div>
</div>
<script>
  let devices = [];
  let bodyPixNet = null;
  let ws;
  let cardMapping = [];  
  let deviceIdToCardIdx = {}; 
  let lastImageMetaId = null;
  let shirts = [];
  const sceneCanvas = document.getElementById("sceneCanvas");
  const uploader = document.getElementById("imageUploader");
  let selectedCardIdx = null;
  const DEFAULT_WS_HOST = '192.168.110.69';
  const host = getHost();
  document.getElementById('wsServerInput').value = window.location.hostname;
(async () => {
  bodyPixNet = await bodyPix.load();
  console.log('Body-Pix æ¨¡å‹åŠ è½½å®Œæ¯•');
})();
function openControlModal(cardIdx) {
  const originalCard = document.getElementById(`device_card_${cardIdx}`);
  const modalBg      = document.getElementById("controlModal");
  const modalContent = document.getElementById("controlModalContent");

  // æ¸…ç©ºæ—§å†…å®¹ï¼Œåªç•™ä¸‹å…³é—­æŒ‰é’®
  const closeBtn = modalContent.querySelector("button");
  modalContent.innerHTML = "";
  modalContent.appendChild(closeBtn);

  // å…‹éš†ä¸€ä»½å¡ç‰‡èŠ‚ç‚¹ï¼ˆå¸¦å­èŠ‚ç‚¹ï¼Œä½†ä¸å¸¦äº‹ä»¶ï¼‰
  const clone = originalCard.cloneNode(true);
  // æ”¾è¿› modal
  modalContent.appendChild(clone);
  modalBg.style.display = "flex";

  // â€”â€” é‡æ–°ç»™ modal ä¸Šçš„æ»‘å—ç»‘å®šäº‹ä»¶ â€”â€” 

  // äº®åº¦æ»‘å—
  const bSl = clone.querySelector(`#brightnessSlider_${cardIdx}`);
  const bTxt = clone.querySelector(`#currentBrightness_${cardIdx}`);
  bSl.addEventListener("input", e => {
    updateBrightness(cardIdx, e.target.value);
    // æ›´æ–° modal è‡ªèº«çš„æ˜¾ç¤º
    bTxt.innerText = e.target.value + "%";
  });

  // è‰²æ¸©æ»‘å—
  const tSl = clone.querySelector(`#tempSlider_${cardIdx}`);
  const tTxt = clone.querySelector(`#currentTemp_${cardIdx}`);
  tSl.addEventListener("input", e => {
    updateTemp(cardIdx, e.target.value);
    tTxt.innerText = e.target.value + "K";
  });

  // ä¸Šä¼ å›¾ç‰‡
  const fileInput = clone.querySelector("input[type=file]");
  if (fileInput) {
    fileInput.addEventListener("change", ev => {
      processImageFile(ev, cardIdx);
      setTimeout(() => {
        const box = clone.querySelector(".color-box");
        const d   = devices[cardMapping[cardIdx]];
        box.style.background = d.mainColorRGB;
        box.innerText        = d.mainColorRGB;

        const [r,g,b] = d.mainColorRGB.match(/\d+/g).map(Number);
        const lum = 0.299*r + 0.587*g + 0.114*b;
        box.style.color = lum>186 ? "#000" : "#fff";
      }, 500);
    });
  }
}

function closeControlModal() {
  document.getElementById("controlModal").style.display = "none";
}

function getHost() {
    const input = document.getElementById('wsServerInput').value.trim();
    if (input) return input;
    if (window.location.hostname) return window.location.hostname;
    return DEFAULT_WS_HOST;
  }

function handleWsMessage(evt) {
  // â€”â€” äºŒè¿›åˆ¶å¸§ â€”â€” 
  if (evt.data instanceof Blob) {
    const cardIdx = deviceIdToCardIdx[lastImageMetaId];
    if (cardIdx == null) {
      console.warn('æ— æ³•å®šä½ cardIdx for', lastImageMetaId);
      return;
    }

    const imgEl = document.getElementById(`preview_${cardIdx}`);
    if (!imgEl) {
      console.warn('æ²¡æ‰¾åˆ° preview å…ƒç´  preview_' + cardIdx);
      return;
    }

    // 1) å…ˆç”¨ objectURL å¿«é€Ÿé¢„è§ˆ
    const objectUrl = URL.createObjectURL(evt.data);
    imgEl.src = objectUrl;
    setTimeout(() => URL.revokeObjectURL(objectUrl), 5000);

    // 2) å†ç”¨ FileReader è½¬ DataURLï¼Œäº¤ç»™ processImageDataUrl
    const reader = new FileReader();
    reader.onload = e => {
      const dataUrl = /** @type {string} */(e.target.result);
      processImageDataUrl(dataUrl, cardIdx);
    };
    reader.readAsDataURL(evt.data);

    return;
  }

  // â€”â€” æ–‡æœ¬å¸§ â€”â€” 
  if (typeof evt.data === 'string') {
    let msg;
    try { msg = JSON.parse(evt.data); }
    catch { return; }

    // â€”â€” 1) å¤„ç† meta â€”â€” 
    if (msg.type === 'image-meta') {
      lastImageMetaId = msg.id;
      return;
    }

    // â€”â€” 2) å¤„ç† state â€”â€” 
    if (msg.type === 'state') {
      const cardIdx = deviceIdToCardIdx[msg.id];
      if (cardIdx == null) return;
      const realIdx = cardMapping[cardIdx];
      const d = devices[realIdx];

      // æ›´æ–°æ•°æ®æ¨¡å‹
      d.brightness = msg.brightness;
      d.temp       = msg.temp;
      d.auto       = msg.auto;

      // åŒæ­¥ UI
      const bSl  = document.getElementById(`brightnessSlider_${cardIdx}`);
      const tSl  = document.getElementById(`tempSlider_${cardIdx}`);
      const bTxt = document.getElementById(`currentBrightness_${cardIdx}`);
      const tTxt = document.getElementById(`currentTemp_${cardIdx}`);
      const chk  = document.querySelector(`#device_card_${cardIdx} input[type=checkbox]`);

      bSl.value      = d.brightness;
      tSl.value      = d.temp;
      bTxt.innerText = d.brightness + '%';
      tTxt.innerText = d.temp + 'K';
      chk.checked    = d.auto;
      bSl.disabled   = d.auto;
      tSl.disabled   = d.auto;

      return;
    }

    // â€”â€” 3) å¦‚æœä½ ä¾ç„¶æœ‰ imageï¼ˆBase64 JSONï¼‰åˆ†æ”¯â€”â€”å¯ä¿ç•™æˆ–ç§»é™¤ â€”â€” 
    if (msg.type === 'image') {
      const cardIdx = deviceIdToCardIdx[msg.id];
      const imgEl = document.getElementById(`preview_${cardIdx}`);
      if (imgEl) imgEl.src = 'data:image/jpeg;base64,' + msg.data;
    }
  }
}

  function initWebSocket() {
  const host = getHost();
  console.log(`ğŸš€ å‡†å¤‡è¿æ¥ WS â†’ ws://${host}:8081`);
  ws = new WebSocket(`ws://${host}:8081`);
  ws.binaryType = 'blob';
  ws.onopen    = () => console.log('âœ… WS å·²è¿æ¥');
  ws.onmessage = handleWsMessage;
  ws.onerror   = e => console.error('ğŸ›‘ WS é”™è¯¯ï¼š', e);
  ws.onclose   = () => {
    console.warn('ğŸ”Œ WS æ–­å¼€ï¼Œ5 ç§’åé‡è¿');
    setTimeout(initWebSocket, 5000);
  };
}

window.addEventListener('load', () => {
  initWebSocket();
  loadAndRenderDevices();
});
  let statusTimer = null;
  
function renderDevices() {
  const container = document.getElementById("deviceContainer");
  container.innerHTML = "";
  cardMapping = []; 
  Object.keys(deviceIdToCardIdx).forEach(k => delete deviceIdToCardIdx[k]);
  const sortedDevices = [...devices].sort((a, b) => {
    const isCamA = a.id.toLowerCase().startsWith("camlamp");
    const isCamB = b.id.toLowerCase().startsWith("camlamp");
    if (isCamA !== isCamB) return isCamA - isCamB;

    const numA = parseInt(a.id.match(/\d+/));
    const numB = parseInt(b.id.match(/\d+/));
    return (isNaN(numA) ? 0 : numA) - (isNaN(numB) ? 0 : numB);
  });

  sortedDevices.forEach((device, cardIdx) => {
    const realIdx = devices.findIndex(d => d.id === device.id);
    cardMapping[cardIdx] = realIdx;
    deviceIdToCardIdx[device.id] = cardIdx;
    const div = document.createElement("div");
    div.className = "lamp-card";
    div.id = `device_card_${cardIdx}`;
    let uploadHtml = '';
    if (device.id.toLowerCase().startsWith('camlamp')) {
      uploadHtml = `
        <div style="margin-top:12px;">
          <div style="font-size:14px; color:#606266;">å®æ—¶é¢„è§ˆï¼š</div>
          <img id="preview_${cardIdx}" 
               src="" 
               style="width:100%; border-radius:8px; margin-top:6px;"
          />
        </div>`;
    }
    div.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0;">${device.id} (${device.ip})</h3>
        <span id="status_${cardIdx}" style="font-size: 13px; color: #666;">æ£€æŸ¥ä¸­...</span>
      </div>
  ${uploadHtml}
        <div style="position: relative; margin-top: 10px;">
    <label>äº®åº¦: <span id="currentBrightness_${cardIdx}">${device.brightness}</span></label>
    <input
      type="range"
      id="brightnessSlider_${cardIdx}"
      min="0" max="100"
      value="${device.brightness}"
      ${device.auto ? 'disabled' : ''}
      oninput="updateBrightness(${cardIdx}, this.value); updateDisplay(${cardIdx});"
    >
  </div>

  <div style="position: relative; margin-top: 10px;">
    <label>è‰²æ¸©: <span id="currentTemp_${cardIdx}">${device.temp}</span></label>
    <input
      type="range"
      id="tempSlider_${cardIdx}"
      min="2700" max="6500" step="100"
      value="${device.temp}"
      ${device.auto ? 'disabled' : ''}
      oninput="updateTemp(${cardIdx}, this.value); updateDisplay(${cardIdx});"
    >
  </div>

  <div class="color-box" id="colorBox_${cardIdx}">
  ${device.mainColorRGB || 'æœªæå–'}
  </div>

  <label style="display:block; margin-top: 8px;">
    <input
      type="checkbox"
      ${device.auto ? 'checked' : ''}
      onchange="toggleAuto(${cardIdx}, this.checked)"
    > è‡ªåŠ¨æ¨¡å¼
  </label>

   ${ device.id.toLowerCase().startsWith('lamp')
  ? `
    <label style="display:block; margin-top:12px; font-size:13px; color:#606266;">ä¸Šä¼ è¡£æœå›¾ç‰‡ï¼ˆè‡ªåŠ¨è¯†åˆ«ä¸»è‰²å¹¶è°ƒæ•´ï¼‰</label>
    <label class="upload-btn-wrapper">
      é€‰æ‹©æ–‡ä»¶
      <input
        type="file"
        accept="image/*"
        onchange="processImageFile(event, ${cardIdx})"
      />
    </label>
  `
  : ``
}
<canvas
  id="autoCanvas_${cardIdx}"
  width="300"
  height="200"
  style="
    display:block;
    width:180px;            /* åŒæ ·é™å®š canvas æ˜¾ç¤ºå¤§å° */
    height:120px;
    margin-top:10px;
    border:1px solid #ddd;
  "
></canvas>

<label class="btn-delete" style="cursor:pointer;">
        åˆ é™¤è®¾å¤‡
      </label>
    `;

    container.appendChild(div);
    const delBtn = div.querySelector('.btn-delete');
    delBtn.addEventListener('click', () => removeDevice(realIdx));

    setTimeout(() => checkDeviceOnline(realIdx, cardIdx), 100);
  });

   if (statusTimer) clearInterval(statusTimer);
  statusTimer = setInterval(() => {
    cardMapping.forEach((realIdx, cardIdx) => {
      checkDeviceOnline(realIdx, cardIdx);
    });
  }, 10000);
}

function addDevice(id, ip) {
  const newDevice = { id, ip, temp: 4000, brightness: 80, auto: true, color: "rgb(0,255,0)",
  broadcastStopped: false
   }; const host = getHost();
  fetch(`http://${host}:3000/devices`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(newDevice)
  })
  .then(res => {
    if (!res.ok) throw new Error("è®¾å¤‡é‡å¤");
    devices.push(newDevice);
    renderDevices();
  })
  .catch(err => alert("æ·»åŠ å¤±è´¥ï¼š" + err.message));

  fetch(`http://${ip}/stopBroadcast`)
    .then(res => res.json())
    .then(data => {
      console.log(`å·²é€šçŸ¥è®¾å¤‡ ${id} (${ip}) åœæ­¢å¹¿æ’­`);
    })
    .catch(err => {
      console.warn(`é€šçŸ¥ ${id} åœæ­¢å¹¿æ’­å¤±è´¥ï¼š`, err);
    });
}

function showAddDeviceModal() {
  document.getElementById("addDeviceModal").style.display = "flex";
}

function hideAddDeviceModal() {
  document.getElementById("addDeviceModal").style.display = "none";
}

function removeDevice(cardIdx) {
  const realIdx = cardMapping[cardIdx];
  const id   = devices[cardIdx].id;
  const ip   = devices[cardIdx].ip;
  const host = getHost();
  fetch(`http://${host}:3000/devices/${id}`, { method: "DELETE" })
    .then(() => {
      // æ¢å¤è®¾å¤‡å¹¿æ’­
      fetch(`http://${ip}/resumeBroadcast`).catch(()=>{}); 
      // ä»æœ¬åœ°æ•°ç»„åˆ æ‰ï¼Œå†é‡æ¸²æŸ“
      devices.splice(cardIdx, 1);
      renderDevices();
    })
    .catch(err => console.error("åˆ é™¤å¤±è´¥", err));
}
let scanWs;
let scanTimer = null;
async function startDeviceScan() {
  document.getElementById("scanStatus").innerText = "ğŸ” æ­£åœ¨æ‰«æè®¾å¤‡ä¸­ï¼Œè¯·ç¨å€™...";
  await loadAndRenderDevices();
  drawScene();
  const hostInput = document.getElementById('wsServerInput').value.trim();
  const host = getHost();
  const url = `ws://${host}:8081`;
  if (ws && ws.readyState === WebSocket.OPEN) {
    console.log('å·²ç»åœ¨æ‰«æä¸­äº†'); 
  
  }
  scanWs = new WebSocket(url)

 scanWs.onopen = () => {
   
  console.log('å·²è¿æ¥åˆ°UDPè½¬å‘æœåŠ¡å™¨ï¼ˆå¼€å§‹æ‰«æï¼‰');
  document.querySelector("button[onclick='startDeviceScan()']").disabled = true;
  // 20ç§’åè‡ªåŠ¨åœæ­¢æ‰«æ
  scanTimer = setTimeout(() => {
    stopDeviceScan();  
    showCustomPrompt("â±ï¸ æ‰«æè¶…æ—¶ï¼Œæ˜¯å¦æ‰‹åŠ¨æ·»åŠ è®¾å¤‡ï¼Ÿ").then((manual) => {
    if (manual) {
      showAddDeviceModal(); 
    }
  });
  }, 20000);
};

  scanWs.onerror = (err) => {
  console.error("WebSocket è¿æ¥å‡ºé”™ï¼š", err);
  stopDeviceScan();

  showCustomPrompt("âŒ æ— æ³•è¿æ¥åˆ°ï¼Œè¯·æ£€æŸ¥ UDP æœåŠ¡æ˜¯å¦å¼€å¯ï¼Œæˆ–æ‰‹åŠ¨è¾“å…¥IPã€‚<br>æ˜¯å¦æ‰‹åŠ¨æ·»åŠ è®¾å¤‡ï¼Ÿ")
    .then((manual) => {
      if (manual) {
        showAddDeviceModal(); // æ‰“å¼€æ‰‹åŠ¨æ·»åŠ å¼¹çª—
      } else {
        console.log("ç”¨æˆ·é€‰æ‹©å–æ¶ˆæ‰‹åŠ¨æ·»åŠ ");
      }
    });
};



scanWs.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  console.log('å‘ç°è®¾å¤‡ï¼š', msg);

  if (msg.type === 'announce') {
    clearTimeout(scanTimer);
    showCustomPrompt(`å‘ç°è®¾å¤‡ï¼š${msg.id} (${msg.ip})<br>æ˜¯å¦æ·»åŠ ï¼Ÿ`)
     .then(confirmAdd => {
        if (confirmAdd) {
          addDevice(msg.id, msg.ip);
        }
        stopDeviceScan();    // ä¸ç®¡é€‰ä¸é€‰ï¼Œéƒ½åœæ­¢æ‰«æå¹¶é‡ç½®çŠ¶æ€
      });
    return;
  
  }
  if (msg.type === 'image') {
    const idx = devices.findIndex(d => d.id === msg.id);
    if (idx >= 0) {
      const imgEl = document.getElementById(`preview_${idx}`);
      document.getElementById(`brightnessSlider_${idx}`).value       = d.brightness;
      
      if (imgEl) {
        imgEl.src = 'data:image/jpeg;base64,' + msg.data;
      }
    }
    return;
  }
  if (msg.type === 'state') {
    // åŒæ­¥äº®åº¦ï¼è‰²æ¸©ï¼auto
    const idx = devices.findIndex(d => d.id === msg.id);
    if (idx < 0) return;
    const d = devices[idx];
    d.brightness = msg.brightness;
    d.temp       = msg.temp;
    d.auto       = msg.auto;

    // æ›´æ–°æ»‘å—å’Œæ˜¾ç¤º
    document.getElementById(`brightnessSlider_${idx}`).value      = d.brightness;
    document.getElementById(`tempSlider_${idx}`).value            = d.temp;
    document.getElementById(`currentBrightness_${idx}`).innerText = d.brightness + '%';
    document.getElementById(`currentTemp_${idx}`).innerText       = d.temp + 'K';

    // è‡ªåŠ¨æ¨¡å¼åˆ‡æ¢æ—¶åŒæ­¥ç¦ç”¨çŠ¶æ€å’Œå‹¾é€‰æ¡†
    document.getElementById(`brightnessSlider_${idx}`).disabled = d.auto;
    document.getElementById(`tempSlider_${idx}`).disabled      = d.auto;
    document.querySelector(`#device_card_${idx} input[type=checkbox]`).checked = d.auto;
    return;
  }
  showCustomPrompt(`å‘ç°è®¾å¤‡ï¼š${data.id} (${data.ip})<br>æ˜¯å¦æ·»åŠ ï¼Ÿ`).then((confirmAdd) => {
    if (confirmAdd) {
      addDevice(data.id, data.ip);
    } else {
      console.log(`ç”¨æˆ·æ‹’ç»æ·»åŠ è®¾å¤‡ï¼š${data.id}`);
    }
    stopDeviceScan(); 
  });
};

scanWs.onclose = () => {
    console.log('æ‰«æå·²åœæ­¢');
    ws = null;
    clearTimeout(scanTimer);
    document.getElementById("scanStatus").innerText = "";
  };
}

function debounce(fn, delay = 200) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn(...args);    
      drawScene();    
    }, delay);
  };
}

const debouncedSend = debounce(send, 200);

function stopDeviceScan() {
  if (scanWs) {
    scanWs.close();
    scanWs = null;
    clearTimeout(scanTimer);
    console.log('æ‰‹åŠ¨åœæ­¢æ‰«æ');
    document.getElementById("scanStatus").innerText = "";
    document.querySelector("button[onclick='startDeviceScan()']").disabled = false;
  }
}

function confirmAddDevice() {
  const id = document.getElementById("modalId").value.trim();
  const ip = document.getElementById("modalIp").value.trim();

  if (!id || !ip) {
    alert("è¯·å¡«å†™å®Œæ•´çš„è®¾å¤‡ ID å’Œ IPï¼");
    return;
  }

  addDevice(id, ip);   
  hideAddDeviceModal(); 
}

let customPromptCallback = null;

function showCustomPrompt(text) {
  return new Promise((resolve) => {
    const box = document.getElementById("customPrompt");
    const dialog = document.getElementById("customPromptBox"); // âœ… åŠ¨ç”»åŠ è¿™é‡Œ

    document.getElementById("customPromptText").innerHTML = text;
    box.style.display = "flex";

    dialog.classList.remove("hide");
    dialog.classList.add("show");

    customPromptCallback = resolve;
  });
}

function customPromptResolve(result) {
  const box = document.getElementById("customPrompt");
  const dialog = document.getElementById("customPromptBox");

  dialog.classList.remove("show");
  dialog.classList.add("hide");

  setTimeout(() => {
    box.style.display = "none";
    customPromptCallback?.(result);
    customPromptCallback = null;
  }, 200); 
}

function checkDeviceOnline(realIdx, cardIdx) {
  const device = devices[realIdx];
  fetch(`http://${device.ip}/status`, { method: "GET", timeout: 3000 })
    .then(res => {
      if (!res.ok) throw new Error("Offline");
      document.getElementById(`status_${cardIdx}`).innerText = "ğŸŸ¢ åœ¨çº¿";
      if (!device.broadcastStopped) {
        fetch(`http://${device.ip}/stopBroadcast`)
          .then(() => {
            console.log(`å·²é€šçŸ¥ ${device.id} åœæ­¢å¹¿æ’­`);
            device.broadcastStopped = true;
          })
          .catch(err => console.warn(`é€šçŸ¥ ${device.id} åœæ­¢å¹¿æ’­å¤±è´¥ï¼š`, err));
      }
    })
    .catch(() => {
      document.getElementById(`status_${cardIdx}`).innerText = "ğŸ”´ ç¦»çº¿";
      device.broadcastStopped = false;
    });
}
  
async function loadAndRenderDevices() {
  const old = {};
  devices.forEach(d => {
    old[d.id] = { brightness: d.brightness, temp: d.temp, auto: d.auto };
  });

  const host = getHost();
  const res  = await fetch(`http://${host}:3000/devices`);
  const data = await res.json();
 
  data.sort((a, b) => {
    const aCam = a.id.toLowerCase().startsWith('camlamp');
    const bCam = b.id.toLowerCase().startsWith('camlamp');
    if (aCam !== bCam) return aCam - bCam;      
    const na = parseInt(a.id.match(/\d+/)?.[0] || '0', 10);
    const nb = parseInt(b.id.match(/\d+/)?.[0] || '0', 10);
    return na - nb;
  });

  devices = data.map(d => ({
    id:       d.id,
    type:     d.id.toLowerCase().startsWith('camlamp') ? 'camlamp' : 'lamp',
    idNum:    parseInt(d.id.match(/\d+/)?.[0] || '0', 10),
    brightness: old[d.id]?.brightness  ?? d.brightness,
    temp:       old[d.id]?.temp        ?? d.temp,
    auto:       old[d.id]?.auto        ?? d.auto,
  }));

  // â€”â€” 4) æ¸²æŸ“ DOM å¡ç‰‡ + 3D åœºæ™¯
  renderDevices();  // ç”Ÿæˆå¡ç‰‡æ—¶ä¹ŸæŒ‰ devices é¡ºåº
  drawScene();      // åœºæ™¯ä¹Ÿæ˜¯æŒ‰ devices é¡ºåºç»˜åˆ¶
}

function updateBrightness(cardIdx, value) {
  const realIdx = cardMapping[cardIdx];
  const d = devices[realIdx];

  d.brightness = Number(value);
  updateDisplay(cardIdx);
  drawScene();
  if (!d.auto) {
    console.log('â†’ è°ƒç”¨ debouncedSend(', cardIdx, ') for', d.id);
    debouncedSend(cardIdx);
  }
}

function updateTemp(cardIdx, value) {
  const realIdx = cardMapping[cardIdx];
  const d = devices[realIdx];

  d.temp = Number(value);
  updateDisplay(cardIdx);
  drawScene();
  if (!d.auto) {
    console.log('â†’ è°ƒç”¨ debouncedSend(', cardIdx, ') for', d.id);
    debouncedSend(cardIdx);
  }
}


function send(cardIdx) {
      const realIdx = cardMapping[cardIdx];
  const device = devices[realIdx];
      const payload = {
        type:       'state',
        id:         device.id,
        brightness: device.brightness,
        temp:       device.temp,
        auto:       device.auto
      };

      // HTTP æ§åˆ¶
      fetch(`http://${device.ip}/setLight`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      const host = getHost();
  fetch(`http://${host}:3000/devices/${device.id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      brightness: device.brightness,
      temp:       device.temp,
      auto:       device.auto
    })
  })

      .then(res => {
        if (!res.ok) throw new Error(res.status);
        console.log(`âœ… [HTTP] å·²å‘ â†’ ${device.id}`);
      })
      .catch(err => console.warn(`âŒ [HTTP] é”™è¯¯ â†’ ${device.id}`, err));

      if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'state',
      id: device.id,
      brightness: device.brightness,
      temp: device.temp,
      auto: device.auto
    }));
  }
}




function processImageFile(event, cardIdx) {
   const realIdx = cardMapping[cardIdx];
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    processImageDataUrl(e.target.result, cardIdx);
  };
  reader.readAsDataURL(file);
}

async function processImageDataUrl(dataUrl, cardIdx) {
  const realIdx = cardMapping[cardIdx];
  const img = new Image();
  img.onload = async () => {
    // â€”â€” A. åœ¨éšè— canvas (this.canvas) ä¸Šç»˜åˆ¶åŸå›¾
    const hidden = document.getElementById('canvas');
    hidden.width = img.width;
    hidden.height = img.height;
    const hCtx = hidden.getContext('2d');
    hCtx.drawImage(img, 0, 0);

    // â€”â€” B. BodyPix åˆ†å‰²
    const partSeg = await bodyPixNet.segmentPersonParts(img, { segmentationThreshold: 0.5 });
    const keepParts = new Set([2,3,4,5,8,9,10,11,12,13]);

    // â€”â€” C. æ„é€  mask
    const maskImg = new ImageData(img.width, img.height);
let hasPart = false;
for (let i = 0; i < partSeg.data.length; i++) {
  const off = i * 4;
  const keep = keepParts.has(partSeg.data[i]);
  maskImg.data[off+3] = keep ? 255 : 0;
  if (keep) hasPart = true;
}

// â€”â€” D. åœ¨ autoCanvas ä¸Šé¢„è§ˆè¡£æœä¸»ä½“ â€”â€” 
const autoCanvas = document.getElementById(`autoCanvas_${cardIdx}`);
autoCanvas.width  = img.width;
autoCanvas.height = img.height;
const pCtx = autoCanvas.getContext('2d');
pCtx.clearRect(0, 0, autoCanvas.width, autoCanvas.height);

if (hasPart) {
  // æœ‰æ£€æµ‹åˆ°ä¸»ä½“ï¼Œå…ˆç”»é®ç½©å†è£åˆ‡
  pCtx.putImageData(maskImg, 0, 0);
  pCtx.globalCompositeOperation = 'source-in';
  pCtx.drawImage(img, 0, 0);
  pCtx.globalCompositeOperation = 'source-over';
} else {
  // æ²¡æ£€æµ‹åˆ°ä¸»ä½“ï¼Œç›´æ¥æ˜¾ç¤ºæ•´å›¾
  pCtx.drawImage(img, 0, 0);
}

      // â€”â€” E. æå–åƒç´ ã€kMeans æ‰¾ä¸»è‰² â€”â€” 
    const imgData = hidden.getContext('2d').getImageData(0,0,hidden.width,hidden.height).data;
    const pixels = [];
    if (hasPart) {
    for (let i = 0; i < partSeg.data.length; i++) {
      if (keepParts.has(partSeg.data[i])) {
        const off = i * 4;
        pixels.push([imgData[off], imgData[off+1], imgData[off+2]]);
      }
    }}
    else {
  for (let off = 0; off < imgData.length; off += 4) {
    pixels.push([imgData[off], imgData[off+1], imgData[off+2]]);
  }
}
    const { centroids, counts } = kMeans(pixels, 3);
    const maxIdx = counts.indexOf(Math.max(...counts));
    const [r,g,b] = centroids[maxIdx];
    // â€”â€” F. è®¡ç®—æ¨èäº®åº¦å’Œè‰²æ¸© â€”â€” 
    const [h, s, v] = rgbToHsv(r, g, b);
    const recTemp = Math.round(h/360*(6500-2700)+2700);
    const recBri = Math.round((1 - v) * 60 + 40);
    
    // â€”â€” G. å­˜åˆ° devices å¹¶æ›´æ–° UI â€”â€” 
    const d = devices[realIdx];
    d.mainColorRGB      = `rgb(${r|0},${g|0},${b|0})`;
    d.recommendedTemp   = recTemp;
    d.recommendedBright = recBri;

    const shirt = shirts.find(s => s.lampIdx === realIdx);
    if (shirt) {
    shirt.color = d.mainColorRGB;
    }
      drawScene();
    if (d.auto) applyRecommendations(cardIdx);
    updateDisplay(cardIdx);
    const box = document.getElementById(`colorBox_${cardIdx}`);
    const rgbStr = `rgb(${r},${g},${b})`;
        if (box) {
      box.style.background = d.mainColorRGB;
      box.innerText        = d.mainColorRGB;
    }
    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

    if (luminance > 186) {
      box.style.color = '#000';
    } else {
      box.style.color = '#fff';
    }
      };
      img.src = dataUrl;

    }

function kMeans(data, k = 3, maxIter = 20, tol = 1e-4) {
  if (!data.length) return { centroids: [], counts: [] };
  const centroids = [];
  centroids.push(data[Math.floor(Math.random() * data.length)]);
  for (let i = 1; i < k; i++) {
    const dists = data.map(p => {
      return Math.min(...centroids.map(c =>
        (p[0]-c[0])**2 + (p[1]-c[1])**2 + (p[2]-c[2])**2
      ));
    });
    const sum = dists.reduce((a,b) => a + b, 0);
    let r = Math.random() * sum;
    let idx = dists.findIndex(d => { r -= d; return r <= 0; });
    centroids.push(data[idx < 0 ? 0 : idx]);
  }

  let labels = new Array(data.length);
  let prevCentroids = centroids.map(c => [...c]);
  let counts = new Array(k).fill(0);

  for (let iter = 0; iter < maxIter; iter++) {
    for (let i = 0; i < data.length; i++) {
      let best = 0, minD = Infinity;
      for (let j = 0; j < k; j++) {
        const d = (data[i][0] - centroids[j][0])**2
                + (data[i][1] - centroids[j][1])**2
                + (data[i][2] - centroids[j][2])**2;
        if (d < minD) { minD = d; best = j; }
      }
      labels[i] = best;
    }

    const sums = Array.from({ length: k }, () => [0, 0, 0]);
    counts = new Array(k).fill(0);
    for (let i = 0; i < data.length; i++) {
      const l = labels[i];
      sums[l][0] += data[i][0];
      sums[l][1] += data[i][1];
      sums[l][2] += data[i][2];
      counts[l]++;
    }

    prevCentroids = centroids.map(c => [...c]);
    for (let j = 0; j < k; j++) {
      if (counts[j] > 0) {
        centroids[j][0] = sums[j][0] / counts[j];
        centroids[j][1] = sums[j][1] / counts[j];
        centroids[j][2] = sums[j][2] / counts[j];
      }
    }

    const shift = centroids.reduce((acc, c, j) => {
      return acc + (c[0]-prevCentroids[j][0])**2
                 + (c[1]-prevCentroids[j][1])**2
                 + (c[2]-prevCentroids[j][2])**2;
    }, 0);
    if (shift < tol) break;
  }

  return { centroids, counts };
}

function rgbToHsv(r, g, b) {
  r/=255; g/=255; b/=255;
  const mx = Math.max(r,g,b), mn = Math.min(r,g,b), d = mx-mn;
  let h = 0;
  if (d) {
    if (mx===r) h = ((g-b)/d)%6;
    else if (mx===g) h = (b-r)/d + 2;
    else h = (r-g)/d + 4;
  }
  h = Math.round(60 * h);
  if (h<0) h+=360;
  const s = mx? d/mx : 0;
  const v = mx;
  return [h, s, v];
}

// 1. æ˜¾ç¤ºæœ€æ–°çš„æ•°å€¼
function updateDisplay(cardIdx) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];
  document.getElementById(`currentBrightness_${cardIdx}`).innerText = d.brightness + '%';
  document.getElementById(`currentTemp_${cardIdx}`).innerText       = d.temp + 'K';
}

// 2. åº”ç”¨æ¨èå€¼
function applyRecommendations(cardIdx) {
  const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];

  // æ›´æ–°æ¨¡å‹
  d.brightness = d.recommendedBright;
  d.temp       = d.recommendedTemp;

  // æ›´æ–°æ»‘æ¡ UIï¼ˆç”¨ cardIdx æ‹¼ idï¼‰
  document.getElementById(`brightnessSlider_${cardIdx}`).value = d.brightness;
  document.getElementById(`tempSlider_${cardIdx}`).value       = d.temp;

  // æ›´æ–°æ–‡å­—æ˜¾ç¤º
  updateDisplay(cardIdx);

  // å‘é€åˆ°è®¾å¤‡ï¼ˆæ‰‹åŠ¨æˆ–é˜²æŠ–ï¼‰
  debouncedSend(cardIdx);
}


function toggleAuto(cardIdx, isAuto) {
   const realIdx = cardMapping[cardIdx];
  if (realIdx == null) return;
  const d = devices[realIdx];

  d.auto = isAuto;

  const bSl = document.getElementById(`brightnessSlider_${cardIdx}`);
  const tSl = document.getElementById(`tempSlider_${cardIdx}`);
  bSl.disabled = isAuto;
  tSl.disabled = isAuto;

  if (isAuto) {
    applyRecommendations(cardIdx); // è¿™ä¼šè°ƒç”¨ send æˆ– debouncedSend
  } else {
    send(cardIdx);
  }
}


function buildLamps() {
  const sorted = [...devices].sort((a, b) => {
    const aCam = a.type === 'camlamp';
    const bCam = b.type === 'camlamp';
    if (aCam !== bCam) return aCam - bCam;      
    return a.idNum - b.idNum;                  
  });

  const cw  = sceneCanvas.width;
  const gap = cw / sorted.length;
  const lampData = sorted.map((d, idx) => ({
    x:             gap/2 + idx * gap,
    brightness:    d.brightness,
    temp:          d.temp,
    originalIndex: devices.indexOf(d)
  }));

  shirts = lampData.map(l => {
    const prev = shirts.find(s => s.lampIdx === l.originalIndex);
    const sleeveW = 20, torsoW = 60;
    return {
      x: l.x - (sleeveW + torsoW/2), 
      y:      320,
      lampIdx: l.originalIndex,
      color:  prev ? prev.color : "#888"
    };
  });


  return lampData;
}

const ctx3 = sceneCanvas.getContext("2d");

function tempToRGB(temp) {
  let r = 255, g = 255 - (temp - 2700) * 0.05, b = 255 - (temp - 2700) * 0.1;
  return `rgba(${r},${Math.round(g)},${Math.round(b)},`;
}

function drawRoom() {
  const c = ctx3, W = sceneCanvas.width, H = sceneCanvas.height;
  c.fillStyle = "#1e1e1e"; c.fillRect(0,0,W,H);
  c.fillStyle = "#2a2a2a";
  c.beginPath(); c.moveTo(0,400); c.lineTo(850,400);
  c.lineTo(900,500); c.lineTo(0,500); c.closePath(); c.fill();
  c.fillStyle = "#3a3a3a"; c.fillRect(0,0,W,30);
}

function drawVolumetricLight(x, brightness, temp) {
  const baseY=70, bottomY=420;
  for (let i=0;i<6;i++){
    const alpha = brightness/100*0.1 - i*0.012;
    const expansion = 50 + i*12;
    const color = tempToRGB(temp) + alpha.toFixed(2) + ")";
    const grad = ctx3.createRadialGradient(x, baseY+30, 5, x, (baseY+bottomY)/2,200);
    grad.addColorStop(0, color); grad.addColorStop(1, "rgba(255,255,255,0)");
    ctx3.fillStyle = grad;
    ctx3.beginPath();
    ctx3.moveTo(x, baseY);
    ctx3.lineTo(x-expansion, bottomY);
    ctx3.lineTo(x+expansion, bottomY);
    ctx3.closePath(); ctx3.fill();
  }
}

function drawLamps() {
  const lamps = buildLamps();
  lamps.forEach(l => {
    // å…‰æŸ±
    drawVolumetricLight(l.x, l.brightness, l.temp);
    // åŠç¯
    ctx3.beginPath();
    ctx3.strokeStyle="#aaa"; ctx3.lineWidth=3;
    ctx3.moveTo(l.x,30); ctx3.lineTo(l.x,60); ctx3.stroke();
    const grad = ctx3.createRadialGradient(l.x,60,2,l.x,65,18);
    grad.addColorStop(0,"#fff"); grad.addColorStop(1,"#555");
    ctx3.beginPath(); ctx3.fillStyle=grad;
    ctx3.ellipse(l.x,65,20,14,0,0,2*Math.PI); ctx3.fill();
    ctx3.beginPath(); ctx3.fillStyle="rgba(0,0,0,0.4)";
    ctx3.ellipse(l.x,72,14,6,0,0,2*Math.PI); ctx3.fill();
  });
}
function drawShirt(s) {
  const ctx = ctx3;
  const x = s.x;
  const y = s.y;
  const torsoW = 60, torsoH = 80;
  const sleeveW = 20, sleeveH = 40, angle = 15;

  // 1. ç”»å½±å­
  ctx.beginPath();
  ctx.ellipse(x + torsoW/2 + sleeveW, y + torsoH + sleeveH + 10, 40, 12, 0, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fill();

  // 2. å·¦è¢–
  ctx.beginPath();
  ctx.moveTo(x,            y + angle);
  ctx.lineTo(x + sleeveW,  y);
  ctx.lineTo(x + sleeveW,  y + sleeveH);
  ctx.lineTo(x,            y + sleeveH + angle);
  ctx.closePath();
  ctx.fillStyle = s.color;
  ctx.fill();

  // 3. èº«ä½“
  ctx.fillStyle = s.color;
  ctx.fillRect(x + sleeveW, y, torsoW, torsoH);

  // 4. å³è¢–
  const rx = x + sleeveW + torsoW;
  ctx.beginPath();
  ctx.moveTo(rx,               y);
  ctx.lineTo(rx + sleeveW,     y + angle);
  ctx.lineTo(rx + sleeveW,     y + sleeveH + angle);
  ctx.lineTo(rx,               y + sleeveH);
  ctx.closePath();
  ctx.fill();

  const cx = x + sleeveW + torsoW/2;
  ctx.beginPath();
  ctx.fillStyle = "#ccc";
  ctx.arc(cx, y, 15,0 , Math.PI, false);
  ctx.fill();
}

function drawScene() {
  ctx3.clearRect(0, 0, sceneCanvas.width, sceneCanvas.height);
  drawRoom();
  const lamps = buildLamps();   
  lamps.forEach(l => drawVolumetricLight(l.x, l.brightness, l.temp));
  drawLamps();
  shirts.forEach(drawShirt);
}

sceneCanvas.addEventListener("click", e => {
  // æŠŠå®¢æˆ·ç«¯åæ ‡è½¬æˆç”»å¸ƒå†…éƒ¨åæ ‡
  const rect = sceneCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (sceneCanvas.width  / rect.width);
  const y = (e.clientY - rect.top ) * (sceneCanvas.height / rect.height);

  // ç„¶åç”¨ x,y å»æ£€æµ‹ï¼š
  const lamps = buildLamps();
  for (let l of lamps) {
    const s = shirts.find(s=>s.lampIdx===l.originalIndex);
    if (!s) continue;
    if (x>=s.x && x<=s.x+60 && y>=s.y && y<=s.y+80) {
      selectedCardIdx = s.lampIdx;
      uploader.click();
      return;
    }
  }
  lamps.forEach(l => {
    if (Math.abs(x - l.x) < 20 && y >= 50 && y <= 100) {
      const realIdx = l.originalIndex;
      const cardIdx = cardMapping.findIndex(idx => idx===realIdx);
      if (cardIdx>=0) openControlModal(cardIdx);
    }
  });
});

uploader.addEventListener("change", e => {
 const file = uploader.files[0];
  if (!file || selectedCardIdx === null) return;
  const reader = new FileReader();
  reader.onload = ev => {
    processImageDataUrl(ev.target.result, selectedCardIdx);
    selectedCardIdx = null;
    uploader.value = '';
  };
  reader.readAsDataURL(file);
});



        const strategyChartCtx = document.getElementById('strategyChart').getContext('2d');
        const strategyChart = new Chart(strategyChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'æ’å®šäº®åº¦ (750)', data: [], borderColor: 'gray', borderWidth: 2, fill: false },
                    { label: 'è‡ªé€‚åº”äº®åº¦', data: [], borderColor: 'blue', borderWidth: 2, fill: false },
                    { label: 'æ··åˆç­–ç•¥', data: [], borderColor: 'green', borderWidth: 2, fill: false }
                ]
            },
            options: {
                responsive: true,
                animation: false,
                scales: {
                    x: { title: { display: true, text: 'æ—¶é—´' } },
                    y: { title: { display: true, text: 'äº®åº¦ (æµæ˜)' }, min: 300, max: 1000 }
                }
            }
        });

        function predictPeople(area) {
            const base = { 40: 20, 60: 35, 80: 50 }[area] || 6;
            return Math.round(base + 10 * Math.sin(Date.now() / 100000) + Math.random() * 10);
        }

        const tempCtx = document.getElementById('tempChart').getContext('2d');
        const distCtx = document.getElementById('distributionChart').getContext('2d');

        let storeArea = 80;
        document.getElementById('storeSelect').addEventListener('change', e => {
            storeArea = parseInt(e.target.value.split(',')[1]);
        });

        const tempChart = new Chart(tempCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'æ¸©åº¦ (Â°C)', data: [], borderColor: 'rgba(75, 192, 192, 1)', fill: false, yAxisID: 'y' },
                    { label: 'äººæµé‡', data: [], borderColor: 'rgba(255, 99, 132, 1)', fill: false, yAxisID: 'y1' }
                ]
            },
            options: {
                responsive: true,
                animation: false,
                scales: {
                    x: { title: { display: true, text: 'æ—¶é—´' } },
                    y: { position: 'left', title: { display: true, text: 'æ¸©åº¦ (Â°C)' }, min: 0, max: 40 },
                    y1: { position: 'right', title: { display: true, text: 'äººæµé‡' }, min: 0, max: 100, grid: { drawOnChartArea: false } }
                }
            }
        });

        const distributionChart = new Chart(distCtx, {
            type: 'bar',
            data: {
                labels: ['ç¯1', 'ç¯2', 'ç¯3', 'ç¯4'],
                datasets: [{ label: 'æ¯ç›ç¯äº®åº¦ (æµæ˜)', data: [400, 400, 400, 400], backgroundColor: 'rgba(54, 162, 235, 0.6)' }]
            },
            options: {
                responsive: true,
                animation: false,
                scales: { y: { min: 300, max: 1000 } }
            }
        });

        // èˆ’é€‚åº¦è®¡ç®—å‡½æ•°ï¼Œè¿”å›0~1
        function comfortScore(temperature, people) {
            // ç†æƒ³æ¸©åº¦22åº¦ï¼Œè¶…è¿‡èŒƒå›´èˆ’é€‚åº¦é™ä½
            let tempComfort = 1 - Math.min(Math.abs(temperature - 22) / 15, 1);

            // äººæµé‡ç†æƒ³èŒƒå›´20~60ï¼Œä¸­é—´å³°å€¼èˆ’é€‚åº¦é«˜
            let idealMin = 20, idealMax = 60;
            let peopleComfort = 0;
            if (people <= idealMin) {
                peopleComfort = people / idealMin; // 0~1
            } else if (people >= idealMax) {
                peopleComfort = (100 - people) / (100 - idealMax); // é€’å‡åˆ°0
                if(peopleComfort < 0) peopleComfort = 0;
            } else {
                peopleComfort = 1;
            }

            // ç»¼åˆèˆ’é€‚åº¦ï¼Œç®€å•ç®—æœ¯å¹³å‡
            return Math.max(0, (tempComfort + peopleComfort) / 2);
        }

        function updateData() {
            const now = new Date();
            const time = now.toLocaleTimeString();
            const temperature = (22 + 5 * Math.sin(Date.now() / 100000)).toFixed(1);
            const people = predictPeople(storeArea);
            const weatherFactor = 1.15;
            const base = 400 + people * 5;
            const adaptive = Math.round(base * weatherFactor);
            const mixed = Math.round(0.3 * 750 + 0.7 * adaptive);

            if (tempChart.data.labels.length >= 12) {
                tempChart.data.labels.shift();
                tempChart.data.datasets[0].data.shift();
                tempChart.data.datasets[1].data.shift();
            }
            tempChart.data.labels.push(time);
            tempChart.data.datasets[0].data.push(temperature);
            tempChart.data.datasets[1].data.push(people);
            tempChart.update();

            distributionChart.data.datasets[0].data = [adaptive, adaptive, adaptive, adaptive];
            distributionChart.update();

            document.getElementById('dateInfo').textContent = 'æ—¥æœŸ: ' + now.toLocaleDateString();
            document.getElementById('weekInfo').textContent = 'æ˜ŸæœŸ: ' + ['æ—¥','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­'][now.getDay()];
            document.getElementById('holidayInfo').textContent = 'æ˜¯å¦èŠ‚å‡æ—¥: å¦';
            document.getElementById('workdayInfo').textContent = 'æ˜¯å¦å·¥ä½œæ—¥: æ˜¯';

            document.getElementById('inputs').innerHTML = `
                æ¸©åº¦: ${temperature} Â°C<br>
                å½“å‰æ—¶é—´: ${time}<br>
                å®æ—¶äººæµé‡: ${people} äºº<br>
                åº—é“ºé¢ç§¯: ${storeArea}ã¡
            `;

            document.getElementById('results').innerHTML = `
                äº®åº¦å…¬å¼: (400 + äººæµé‡Ã—5) Ã— å¤©æ°”å› å­(1.15)<br>
                å½“å‰äº®åº¦: ${adaptive} æµæ˜/ç›
            `;

            if (strategyChart.data.labels.length >= 20) {
                strategyChart.data.labels.shift();
                strategyChart.data.datasets.forEach(ds => ds.data.shift());
            }
            strategyChart.data.labels.push(time);
            strategyChart.data.datasets[0].data.push(750);
            strategyChart.data.datasets[1].data.push(adaptive);
            strategyChart.data.datasets[2].data.push(mixed);
            strategyChart.update();

            const comfort = comfortScore(parseFloat(temperature), people);

            // èŠ‚èƒ½ç‡ = æœ€å¤§ä¸ä½äº0ï¼Œä¹˜ä»¥èˆ’é€‚åº¦ç³»æ•°
            const savingRate = Math.max(0, (1 - mixed / 750) * 100 * comfort).toFixed(1);

            document.getElementById('savingResult').textContent = `èŠ‚èƒ½ç‡: ${savingRate}% (èˆ’é€‚åº¦: ${(comfort*100).toFixed(0)}%)`;
        }

        updateData();
        setInterval(updateData, 10000);

        interact('.draggable')
            .draggable({
                listeners: {
                    move(event) {
                        const target = event.target;
                        const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                        const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                        target.style.transform = `translate(${x}px, ${y}px)`;
                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }
                }
            })
            .resizable({
                edges: { left: true, right: true, bottom: true, top: true },
                listeners: {
                    move(event) {
                        const target = event.target;
                        let x = (parseFloat(target.getAttribute('data-x')) || 0);
                        let y = (parseFloat(target.getAttribute('data-y')) || 0);

                        // æ›´æ–°å°ºå¯¸
                        target.style.width = event.rect.width + 'px';
                        target.style.height = event.rect.height + 'px';

                        // è°ƒæ•´ä½ç½®
                        x += event.deltaRect.left;
                        y += event.deltaRect.top;

                        target.style.transform = `translate(${x}px, ${y}px)`;
                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);

                        // è°ƒæ•´å†…éƒ¨canvaså°ºå¯¸ï¼Œé‡ç»˜å›¾è¡¨
                        const canvas = target.querySelector('canvas');
                        if(canvas) {
                            canvas.width = event.rect.width;
                            canvas.height = event.rect.height;
                            if(canvas.id === 'tempChart') tempChart.resize();
                            else if(canvas.id === 'distributionChart') distributionChart.resize();
                        }
                    }
                },
                modifiers: [
                    interact.modifiers.restrictSize({
                        min: { width: 250, height: 150 },
                        max: { width: 700, height: 600 }
                    })
                ]
            });

        // äº®åº¦ç­–ç•¥å®æ—¶å¯¹æ¯”å›¾ä¸å…è®¸æ‹–æ‹½ç¼©æ”¾
        const strategyWrapper = document.getElementById('strategyChartContainer');
        strategyWrapper.style.pointerEvents = 'auto'; // ç¡®ä¿å¯äº¤äº’ä½†ä¸è¢«æ‹–æ‹½

        // æ—¥å¤œæ¨¡å¼åˆ‡æ¢ï¼ˆç®€å•ï¼‰
        const toggleBtn = document.getElementById('toggleMode');
        let dayMode = true;
        toggleBtn.onclick = () => {
            dayMode = !dayMode;
            if(dayMode) {
                document.body.style.background = 'rgba(173, 216, 230, 0.3)';
                document.body.style.color = '#333';
            } else {
                document.body.style.background = '#222';
                document.body.style.color = '#eee';
            }
        };
    </script></div>
</body></html>